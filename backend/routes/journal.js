const express = require('express');
const router = express.Router();
const JournalEntry = require('../models/JournalEntry');
const User = require('../models/User');
const auth = require('../middleware/auth');
const aiCoachService = require('../services/aiCoachService');
const fs = require('fs');
const path = require('path');
const axios = require('axios');
const multer = require('multer');
const FormData = require('form-data');

// Create journals audio directory if it doesn't exist
const journalsDir = path.join(__dirname, '../../assets/audio/journals');
if (!fs.existsSync(journalsDir)) {
  fs.mkdirSync(journalsDir, { recursive: true });
}

// Helper function for automatic AI Coach analysis with relapse detection
const triggerAICoachAnalysis = async (journalEntry) => {
  try {
    console.log(`üîç Analyzing journal entry ${journalEntry._id} for triggers and relapse detection...`);
    
    // Try AI analysis first
    const analysis = await aiCoachService.analyzeJournalEntry(journalEntry.userId, journalEntry);
    
    // If AI analysis works, use it
    if (analysis && analysis.triggersDetected && analysis.triggersDetected.length > 0) {
      console.log(`‚ö†Ô∏è  Triggers detected in journal entry:`, analysis.triggersDetected);
      
      // Check if any triggers indicate actual relapse (not just thoughts)
      const relapseIndicators = analysis.triggersDetected.filter(trigger => 
        trigger.confidence > 0.6 && 
        (trigger.isActualRelapse === true || 
         (trigger.context && (
           trigger.context.toLowerCase().includes('actual relapse') ||
           trigger.context.toLowerCase().includes('used') || 
           trigger.context.toLowerCase().includes('drank') || 
           trigger.context.toLowerCase().includes('gedronken') ||
           trigger.context.toLowerCase().includes('heb gedronken') ||
           trigger.context.toLowerCase().includes('wijn gedronken') ||
           trigger.context.toLowerCase().includes('alcohol gedronken') ||
           trigger.context.toLowerCase().includes('smoked') ||
           trigger.context.toLowerCase().includes('gerookt') ||
           trigger.context.toLowerCase().includes('heb gerookt') ||
           trigger.context.toLowerCase().includes('gambled') ||
           trigger.context.toLowerCase().includes('gegokt') ||
           trigger.context.toLowerCase().includes('bought') ||
           trigger.context.toLowerCase().includes('gekocht') ||
           trigger.context.toLowerCase().includes('relapsed') ||
           trigger.context.toLowerCase().includes('teruggevallen') ||
           trigger.context.toLowerCase().includes('gave in') ||
           trigger.context.toLowerCase().includes('toegegeven') ||
           trigger.context.toLowerCase().includes('bezweken')
         )))
      );
      
      if (relapseIndicators.length > 0) {
        console.log(`üö® Relapse indicators found:`, relapseIndicators);
        await handleAutomaticRelapseDetection(journalEntry.userId, relapseIndicators, journalEntry);
      }
    } else {
      console.log('‚ö†Ô∏è  No AI triggers detected or AI unavailable, falling back to keyword-based detection...');
      
      // Fallback: Keyword-based relapse detection
      const keywordRelapseIndicators = await performKeywordBasedRelapseDetection(journalEntry);
      
      if (keywordRelapseIndicators.length > 0) {
        console.log(`üö® Keyword-based relapse indicators found:`, keywordRelapseIndicators);
        await handleAutomaticRelapseDetection(journalEntry.userId, keywordRelapseIndicators, journalEntry);
      }
    }
  } catch (error) {
    console.error('Error in automatic AI Coach analysis:', error);
    
    // Even if AI fails, try keyword fallback
    try {
      console.log('üîÑ AI failed, attempting keyword-based detection...');
      const keywordRelapseIndicators = await performKeywordBasedRelapseDetection(journalEntry);
      
      if (keywordRelapseIndicators.length > 0) {
        console.log(`üö® Keyword-based relapse indicators found:`, keywordRelapseIndicators);
        await handleAutomaticRelapseDetection(journalEntry.userId, keywordRelapseIndicators, journalEntry);
      }
    } catch (keywordError) {
      console.error('Error in keyword-based relapse detection:', keywordError);
    }
  }
};

// Keyword-based relapse detection fallback when AI is unavailable
const performKeywordBasedRelapseDetection = async (journalEntry) => {
  try {
    const Addiction = require('../models/Addiction');
    
    // Get user's addictions to know what to look for (include all statuses that could relapse)
    const addictions = await Addiction.find({ 
      userId: journalEntry.userId, 
      status: { $in: ['active', 'recovering', 'clean'] } 
    });
    
    const relapseIndicators = [];
    const content = (journalEntry.content + ' ' + journalEntry.title).toLowerCase();
    
    // Define comprehensive relapse keywords by addiction type and language
    const addictionKeywords = {
      alcohol: {
        keywords: {
          'en': ['drank', 'drunk', 'wine', 'beer', 'alcohol', 'whisky', 'vodka', 'gin', 'champagne', 'cocktail', 'had drinks', 'drinking'],
          'nl': ['gedronken', 'heb gedronken', 'wijn gedronken', 'alcohol gedronken', 'bier gedronken', 'wodka', 'gin', 'alcohol'],
          'de': ['getrunken', 'hab getrunken', 'wein getrunken', 'bier getrunken', 'alkohol', 'whisky', 'wodka'],
          'fr': ['bu', 'j\'ai bu', 'vin bu', 'bi√®re bu', 'alcool', 'whisky', 'vodka', 'champagne'],
          'es': ['bebido', 'he bebido', 'vino bebido', 'cerveza bebida', 'alcohol', 'whisky', 'vodka'],
          'it': ['bevuto', 'ho bevuto', 'vino bevuto', 'birra bevuta', 'alcol', 'whisky', 'vodka'],
          'pt': ['bebi', 'bebido', 'vinho bebido', 'cerveja bebida', '√°lcool', 'whisky', 'vodka'],
          'ru': ['–ø–∏–ª', '–≤—ã–ø–∏–ª', '–ø—å—è–Ω', '–∞–ª–∫–æ–≥–æ–ª—å', '–≤–æ–¥–∫–∞', '–ø–∏–≤–æ', '–≤–∏–Ω–æ', '–≤–∏—Å–∫–∏']
        },
        contextPhrases: {
          'en': ['had alcohol', 'drank too much', 'got drunk', 'drinking again'],
          'nl': ['heb alcohol', 'veel gedronken', 'weer gedronken', 'dronken geworden', 'te veel gedronken'],
          'de': ['hab alkohol', 'viel getrunken', 'wieder getrunken', 'betrunken geworden'],
          'fr': ['j\'ai de l\'alcool', 'trop bu', 'encore bu', 'saoul'],
          'es': ['he bebido alcohol', 'bebido demasiado', 'bebido otra vez', 'borracho'],
          'it': ['ho bevuto alcol', 'bevuto troppo', 'bevuto ancora', 'ubriaco'],
          'pt': ['bebi √°lcool', 'bebi demais', 'bebi novamente', 'b√™bado'],
          'ru': ['–≤—ã–ø–∏–ª –∞–ª–∫–æ–≥–æ–ª—å', '–º–Ω–æ–≥–æ –≤—ã–ø–∏–ª', '—Å–Ω–æ–≤–∞ –ø–∏–ª', '–ø—å—è–Ω']
        }
      },
      smoking: {
        keywords: {
          'en': ['smoked', 'cigarette', 'tobacco', 'vaping', 'e-cigarette', 'nicotine', 'lighter'],
          'nl': ['gerookt', 'heb gerookt', 'sigaret gerookt', 'sigaretten gekocht', 'sigaret', 'tabak', 'roken'],
          'de': ['geraucht', 'hab geraucht', 'zigarette', 'tabak', 'rauchen', 'nikotine'],
          'fr': ['fum√©', 'j\'ai fum√©', 'cigarette', 'tabac', 'fumer', 'nicotine'],
          'es': ['fumado', 'he fumado', 'cigarrillo', 'tabaco', 'fumar', 'nicotina'],
          'it': ['fumato', 'ho fumato', 'sigaretta', 'tabacco', 'fumare', 'nicotina'],
          'pt': ['fumei', 'fumado', 'cigarro', 'tabaco', 'fumar', 'nicotina'],
          'ru': ['–∫—É—Ä–∏–ª', '–ø–æ–∫—É—Ä–∏–ª', '—Å–∏–≥–∞—Ä–µ—Ç–∞', '—Ç–∞–±–∞–∫', '–Ω–∏–∫–æ—Ç–∏–Ω']
        },
        contextPhrases: {
          'en': ['smoked again', 'bought cigarettes', 'lit cigarette', 'smoking break'],
          'nl': ['heb gerookt', 'weer gerookt', 'sigaret opgestoken', 'pakje gekocht'],
          'de': ['wieder geraucht', 'zigaretten gekauft', 'zigarette angez√ºndet'],
          'fr': ['fum√© encore', 'achet√© cigarettes', 'allum√© cigarette'],
          'es': ['fumado otra vez', 'comprado cigarrillos', 'encendido cigarrillo'],
          'it': ['fumato ancora', 'comprato sigarette', 'acceso sigaretta'],
          'pt': ['fumei novamente', 'comprei cigarros', 'acendi cigarro'],
          'ru': ['—Å–Ω–æ–≤–∞ –∫—É—Ä–∏–ª', '–∫—É–ø–∏–ª —Å–∏–≥–∞—Ä–µ—Ç—ã', '–∑–∞–∫—É—Ä–∏–ª']
        }
      },
      gambling: {
        keywords: {
          'en': ['gambled', 'casino', 'lottery', 'poker', 'bet', 'betting', 'slot machine'],
          'nl': ['gegokt', 'heb gegokt', 'casino bezocht', 'geld verloren aan gokken', 'weddenschap', 'pokeren'],
          'de': ['gespielt', 'hab gespielt', 'kasino', 'lotterie', 'poker', 'wette'],
          'fr': ['jou√©', 'j\'ai jou√©', 'casino', 'loterie', 'poker', 'pari'],
          'es': ['apostado', 'he apostado', 'casino', 'loter√≠a', 'p√≥ker', 'apuesta'],
          'it': ['scommesso', 'ho scommesso', 'casin√≤', 'lotteria', 'poker', 'scommessa'],
          'pt': ['apostei', 'apostado', 'casino', 'loteria', 'poker', 'aposta'],
          'ru': ['–∏–≥—Ä–∞–ª', '—Å—ã–≥—Ä–∞–ª', '–∫–∞–∑–∏–Ω–æ', '–ª–æ—Ç–µ—Ä–µ—è', '–ø–æ–∫–µ—Ä', '—Å—Ç–∞–≤–∫–∞']
        },
        contextPhrases: {
          'en': ['lost money gambling', 'went to casino', 'placed bet', 'gambling again'],
          'nl': ['heb gegokt', 'geld verspeeld', 'weer gegokt', 'casino gegaan'],
          'de': ['geld verspielt', 'wieder gespielt', 'kasino gegangen'],
          'fr': ['perdu argent', 'encore jou√©', 'casino all√©'],
          'es': ['perdido dinero', 'apostado otra vez', 'casino ido'],
          'it': ['perso soldi', 'scommesso ancora', 'casin√≤ andato'],
          'pt': ['perdi dinheiro', 'apostei novamente', 'casino fui'],
          'ru': ['–ø–æ—Ç–µ—Ä—è–ª –¥–µ–Ω—å–≥–∏', '—Å–Ω–æ–≤–∞ –∏–≥—Ä–∞–ª', '–≤ –∫–∞–∑–∏–Ω–æ —Ö–æ–¥–∏–ª']
        }
      },
      shopping: {
        keywords: {
          'en': ['bought', 'shopping spree', 'impulse buy', 'purchased', 'credit card', 'spent money'],
          'nl': ['gekocht', 'teveel gekocht', 'shopping gedaan', 'geld uitgegeven', 'winkelen'],
          'de': ['gekauft', 'zu viel gekauft', 'shopping gemacht', 'geld ausgegeben'],
          'fr': ['achet√©', 'trop achet√©', 'shopping fait', 'argent d√©pens√©'],
          'es': ['comprado', 'demasiado comprado', 'shopping hecho', 'dinero gastado'],
          'it': ['comprato', 'troppo comprato', 'shopping fatto', 'soldi spesi'],
          'pt': ['comprei', 'comprado demais', 'shopping feito', 'dinheiro gasto'],
          'ru': ['–∫—É–ø–∏–ª', '–º–Ω–æ–≥–æ –∫—É–ø–∏–ª', '—à–æ–ø–ø–∏–Ω–≥', '–ø–æ—Ç—Ä–∞—Ç–∏–ª –¥–µ–Ω—å–≥–∏']
        },
        contextPhrases: {
          'en': ['impulse bought', 'shopping addiction', 'spent too much', 'maxed credit card'],
          'nl': ['teveel gekocht', 'geld weggegooid', 'impulsief gekocht', 'weer winkelen'],
          'de': ['zu viel gekauft', 'geld verschwendet', 'impulsiv gekauft'],
          'fr': ['trop achet√©', 'argent gaspill√©', 'achet√© impulsivement'],
          'es': ['comprado demasiado', 'dinero desperdiciado', 'comprado impulsivamente'],
          'it': ['comprato troppo', 'soldi sprecati', 'comprato impulsivamente'],
          'pt': ['comprei demais', 'dinheiro desperdi√ßado', 'comprei impulsivamente'],
          'ru': ['–∫—É–ø–∏–ª –º–Ω–æ–≥–æ', '–ø–æ—Ç—Ä–∞—Ç–∏–ª –¥–µ–Ω—å–≥–∏', '–∏–º–ø—É–ª—å—Å–∏–≤–Ω–æ –∫—É–ø–∏–ª']
        }
      },
      drugs: {
        keywords: {
          'en': ['used drugs', 'cocaine', 'marijuana', 'weed', 'pills', 'heroin', 'meth', 'high'],
          'nl': ['drugs gebruikt', 'coca√Øne', 'marihuana', 'wiet', 'pillen', 'hero√Øne', 'high'],
          'de': ['drogen genommen', 'kokain', 'marihuana', 'pillen', 'heroin', 'high'],
          'fr': ['drogues pris', 'coca√Øne', 'marijuana', 'pilules', 'h√©ro√Øne', 'high'],
          'es': ['drogas usado', 'coca√≠na', 'marihuana', 'pastillas', 'hero√≠na', 'high'],
          'it': ['droghe usato', 'cocaina', 'marijuana', 'pillole', 'eroina', 'high'],
          'pt': ['drogas usei', 'coca√≠na', 'maconha', 'p√≠lulas', 'hero√≠na', 'chapado'],
          'ru': ['–Ω–∞—Ä–∫–æ—Ç–∏–∫–∏', '–∫–æ–∫–∞–∏–Ω', '–º–∞—Ä–∏—Ö—É–∞–Ω–∞', '—Ç–∞–±–ª–µ—Ç–∫–∏', '–≥–µ—Ä–æ–∏–Ω', '–∫–∞–π—Ñ']
        },
        contextPhrases: {
          'en': ['used again', 'got high', 'relapsed drugs', 'bought drugs'],
          'nl': ['weer gebruikt', 'high geworden', 'terugval drugs', 'drugs gekocht'],
          'de': ['wieder genommen', 'high geworden', 'r√ºckfall drogen'],
          'fr': ['pris encore', 'high devenu', 'rechute drogues'],
          'es': ['usado otra vez', 'high quedado', 'reca√≠da drogas'],
          'it': ['usato ancora', 'high diventato', 'ricaduta droghe'],
          'pt': ['usei novamente', 'chapei', 'reca√≠da drogas'],
          'ru': ['—Å–Ω–æ–≤–∞ —É–ø–æ—Ç—Ä–µ–±–∏–ª', '–Ω–∞–∫—É—Ä–∏–ª—Å—è', '—Ä–µ—Ü–∏–¥–∏–≤ –Ω–∞—Ä–∫–æ—Ç–∏–∫–∏']
        }
      },
      social_media: {
        keywords: {
          'en': ['scrolled', 'instagram', 'facebook', 'tiktok', 'twitter', 'social media', 'phone addiction'],
          'nl': ['gescrold', 'instagram', 'facebook', 'tiktok', 'twitter', 'sociale media', 'telefoon verslaving'],
          'de': ['gescrollt', 'instagram', 'facebook', 'tiktok', 'twitter', 'soziale medien'],
          'fr': ['scroll√©', 'instagram', 'facebook', 'tiktok', 'twitter', 'm√©dias sociaux'],
          'es': ['navegado', 'instagram', 'facebook', 'tiktok', 'twitter', 'redes sociales'],
          'it': ['scrollato', 'instagram', 'facebook', 'tiktok', 'twitter', 'social media'],
          'pt': ['rolei', 'instagram', 'facebook', 'tiktok', 'twitter', 'redes sociais'],
          'ru': ['—Å–∫—Ä–æ–ª–ª–∏–ª', '–∏–Ω—Å—Ç–∞–≥—Ä–∞–º', '—Ñ–µ–π—Å–±—É–∫', '—Ç–∏–∫—Ç–æ–∫', '—Ç–≤–∏—Ç—Ç–µ—Ä', '—Å–æ—Ü —Å–µ—Ç–∏']
        },
        contextPhrases: {
          'en': ['scrolled for hours', 'endless scrolling', 'social media binge', 'phone all day'],
          'nl': ['uren gescrold', 'eindeloos scrollen', 'sociale media binge', 'hele dag telefoon'],
          'de': ['stunden gescrollt', 'endlos gescrollt', 'soziale medien sucht'],
          'fr': ['scroll√© heures', 'scroll infini', 'binge m√©dias sociaux'],
          'es': ['navegado horas', 'scroll infinito', 'atrac√≥n redes sociales'],
          'it': ['scrollato ore', 'scroll infinito', 'binge social media'],
          'pt': ['rolei horas', 'scroll infinito', 'v√≠cio redes sociais'],
          'ru': ['—Å–∫—Ä–æ–ª–ª–∏–ª —á–∞—Å—ã', '–±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Å–∫—Ä–æ–ª–ª', '–∑–∞–≤–∏—Å–∞–Ω–∏–µ –≤ —Å–æ—Ü—Å–µ—Ç—è—Ö']
        }
      },
      gaming: {
        keywords: {
          'en': ['played games', 'gaming', 'xbox', 'playstation', 'computer games', 'video games', 'online gaming'],
          'nl': ['games gespeeld', 'gamen', 'xbox', 'playstation', 'computergames', 'videogames', 'online gamen'],
          'de': ['spiele gespielt', 'gaming', 'xbox', 'playstation', 'computerspiele', 'videospiele'],
          'fr': ['jou√© jeux', 'gaming', 'xbox', 'playstation', 'jeux ordinateur', 'jeux vid√©o'],
          'es': ['jugado juegos', 'gaming', 'xbox', 'playstation', 'juegos ordenador', 'videojuegos'],
          'it': ['giocato giochi', 'gaming', 'xbox', 'playstation', 'giochi computer', 'videogame'],
          'pt': ['joguei jogos', 'gaming', 'xbox', 'playstation', 'jogos computador', 'videogame'],
          'ru': ['–∏–≥—Ä–∞–ª –∏–≥—Ä—ã', '–≥–µ–π–º–∏–Ω–≥', '–∏–∫—Å–±–æ–∫—Å', '–ø–ª–µ–π—Å—Ç–µ–π—à–Ω', '–∫–æ–º–ø—å—é—Ç–µ—Ä–Ω—ã–µ –∏–≥—Ä—ã', '–≤–∏–¥–µ–æ–∏–≥—Ä—ã']
        },
        contextPhrases: {
          'en': ['gamed all night', 'gaming binge', 'played for hours', 'gaming relapse'],
          'nl': ['hele nacht gamed', 'gaming binge', 'uren gespeeld', 'game terugval'],
          'de': ['ganze nacht gespielt', 'gaming binge', 'stunden gespielt'],
          'fr': ['jou√© toute nuit', 'gaming binge', 'jou√© heures'],
          'es': ['jugado toda noche', 'gaming atrac√≥n', 'jugado horas'],
          'it': ['giocato tutta notte', 'gaming binge', 'giocato ore'],
          'pt': ['joguei toda noite', 'gaming v√≠cio', 'joguei horas'],
          'ru': ['–∏–≥—Ä–∞–ª –≤—Å—é –Ω–æ—á—å', '–∏–≥—Ä–æ–≤–æ–π –∑–∞–ø–æ–π', '–∏–≥—Ä–∞–ª —á–∞—Å–∞–º–∏']
        }
      },
      food: {
        keywords: {
          'en': ['overate', 'binge eating', 'fast food', 'junk food', 'emotional eating', 'food addiction'],
          'nl': ['teveel gegeten', 'binge eten', 'fastfood', 'junkfood', 'emotioneel eten', 'eetverslaving'],
          'de': ['zu viel gegessen', 'binge essen', 'fastfood', 'junkfood', 'emotional essen'],
          'fr': ['trop mang√©', 'binge alimentaire', 'fastfood', 'junkfood', 'manger √©motionnel'],
          'es': ['comido demasiado', 'atrac√≥n comida', 'comida r√°pida', 'comida basura', 'comer emocional'],
          'it': ['mangiato troppo', 'binge alimentare', 'fastfood', 'junkfood', 'mangiare emotivo'],
          'pt': ['comi demais', 'compuls√£o alimentar', 'fastfood', 'junkfood', 'comer emocional'],
          'ru': ['–ø–µ—Ä–µ–µ–ª', '–ø–∏—â–µ–≤–æ–π –∑–∞–ø–æ–π', '—Ñ–∞—Å—Ç—Ñ—É–¥', '–≤—Ä–µ–¥–Ω–∞—è –µ–¥–∞', '—ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø–∏—Ç–∞–Ω–∏–µ']
        },
        contextPhrases: {
          'en': ['ate too much', 'food binge', 'comfort eating', 'emotional eating episode'],
          'nl': ['te veel gegeten', 'eet binge', 'troost eten', 'emotioneel eet episode'],
          'de': ['zu viel gegessen', 'ess binge', 'trost essen'],
          'fr': ['trop mang√©', 'binge alimentaire', 'manger r√©confort'],
          'es': ['comido mucho', 'atrac√≥n comida', 'comer consuelo'],
          'it': ['mangiato molto', 'binge cibo', 'mangiare conforto'],
          'pt': ['comi muito', 'compuls√£o comer', 'comer consola√ß√£o'],
          'ru': ['–º–Ω–æ–≥–æ –µ–ª', '–ø–∏—â–µ–≤–æ–π —Å—Ä—ã–≤', '–∑–∞–µ–¥–∞–Ω–∏–µ —Å—Ç—Ä–µ—Å—Å–∞']
        }
      },
      caffeine: {
        keywords: {
          'en': ['coffee', 'caffeine', 'energy drinks', 'red bull', 'monster', 'espresso', 'latte', 'cappuccino', 'cola', 'tea'],
          'nl': ['koffie', 'cafe√Øne', 'energiedranken', 'red bull', 'monster', 'espresso', 'latte', 'cappuccino', 'cola', 'thee'],
          'de': ['kaffee', 'koffein', 'energydrinks', 'red bull', 'monster', 'espresso', 'latte', 'cappuccino', 'cola', 'tee'],
          'fr': ['caf√©', 'caf√©ine', 'boissons √©nergisantes', 'red bull', 'monster', 'espresso', 'latte', 'cappuccino', 'cola', 'th√©'],
          'es': ['caf√©', 'cafe√≠na', 'bebidas energ√©ticas', 'red bull', 'monster', 'espresso', 'latte', 'cappuccino', 'cola', 't√©'],
          'it': ['caff√®', 'caffeina', 'energy drink', 'red bull', 'monster', 'espresso', 'latte', 'cappuccino', 'cola', 't√®'],
          'pt': ['caf√©', 'cafe√≠na', 'energ√©ticos', 'red bull', 'monster', 'espresso', 'latte', 'cappuccino', 'cola', 'ch√°'],
          'ru': ['–∫–æ—Ñ–µ', '–∫–æ—Ñ–µ–∏–Ω', '—ç–Ω–µ—Ä–≥–µ—Ç–∏–∫–∏', '—Ä–µ–¥ –±—É–ª–ª', '–º–æ–Ω—Å—Ç–µ—Ä', '—ç—Å–ø—Ä–µ—Å—Å–æ', '–ª–∞—Ç—Ç–µ', '–∫–∞–ø—É—á–∏–Ω–æ', '–∫–æ–ª–∞', '—á–∞–π'],
          'ja': ['„Ç≥„Éº„Éí„Éº', '„Ç´„Éï„Çß„Ç§„É≥', '„Ç®„Éä„Ç∏„Éº„Éâ„É™„É≥„ÇØ', '„É¨„ÉÉ„Éâ„Éñ„É´', '„É¢„É≥„Çπ„Çø„Éº', '„Ç®„Çπ„Éó„É¨„ÉÉ„ÇΩ', '„É©„ÉÜ', '„Ç´„Éó„ÉÅ„Éº„Éé', '„Ç≥„Éº„É©', 'Ëå∂'],
          'ko': ['Ïª§Ìîº', 'Ïπ¥ÌéòÏù∏', 'ÏóêÎÑàÏßÄÎìúÎßÅÌÅ¨', 'Î†àÎìúÎ∂à', 'Î™¨Ïä§ÌÑ∞', 'ÏóêÏä§ÌîÑÎ†àÏÜå', 'ÎùºÌÖå', 'Ïπ¥Ìë∏ÏπòÎÖ∏', 'ÏΩúÎùº', 'Ï∞®'],
          'zh': ['ÂíñÂï°', 'ÂíñÂï°Âõ†', 'ËÉΩÈáèÈ•ÆÊñô', 'Á∫¢Áâõ', 'ÊÄ™Áâ©', 'ÊÑèÂºèÊµìÁº©', 'ÊãøÈìÅ', 'Âç°Â∏ÉÂ•áËØ∫', 'ÂèØ‰πê', 'Ëå∂'],
          'ar': ['ŸÇŸáŸàÿ©', 'ŸÉÿßŸÅŸäŸäŸÜ', 'ŸÖÿ¥ÿ±Ÿàÿ®ÿßÿ™ ÿßŸÑÿ∑ÿßŸÇÿ©', 'ÿ±ŸäÿØ ÿ®ŸàŸÑ', 'ŸÖŸàŸÜÿ≥ÿ™ÿ±', 'ÿ•ÿ≥ÿ®ÿ±Ÿäÿ≥Ÿà', 'ŸÑÿßÿ™ŸäŸá', 'ŸÉÿßÿ®ÿ™ÿ¥ŸäŸÜŸà', 'ŸÉŸàŸÑÿß', 'ÿ¥ÿßŸä'],
          'hi': ['‡§ï‡•â‡§´‡•Ä', '‡§ï‡•à‡§´‡•Ä‡§®', '‡§è‡§®‡§∞‡•ç‡§ú‡•Ä ‡§°‡•ç‡§∞‡§ø‡§Ç‡§ï', '‡§∞‡•á‡§° ‡§¨‡•Å‡§≤', '‡§Æ‡•â‡§®‡•ç‡§∏‡•ç‡§ü‡§∞', '‡§è‡§∏‡•ç‡§™‡•ç‡§∞‡•á‡§∏‡•ã', '‡§≤‡§ü‡•ç‡§ü‡•á', '‡§ï‡•à‡§™‡•ç‡§™‡•Å‡§ö‡§ø‡§®‡•ã', '‡§ï‡•ã‡§≤‡§æ', '‡§ö‡§æ‡§Ø']
        },
        contextPhrases: {
          'en': ['too much coffee', 'caffeine overdose', 'can\'t function without coffee', 'coffee addiction', 'multiple cups', 'caffeine crash'],
          'nl': ['te veel koffie', 'cafe√Øne overdosis', 'kan niet functioneren zonder koffie', 'koffie verslaving', 'meerdere kopjes', 'cafe√Øne crash'],
          'de': ['zu viel kaffee', 'koffein √ºberdosis', 'kann nicht ohne kaffee funktionieren', 'kaffee sucht', 'mehrere tassen', 'koffein crash'],
          'fr': ['trop de caf√©', 'overdose caf√©ine', 'ne peux pas fonctionner sans caf√©', 'addiction caf√©', 'plusieurs tasses', 'crash caf√©ine'],
          'es': ['demasiado caf√©', 'sobredosis cafe√≠na', 'no puedo funcionar sin caf√©', 'adicci√≥n caf√©', 'm√∫ltiples tazas', 'baj√≥n cafe√≠na'],
          'it': ['troppo caff√®', 'overdose caffeina', 'non posso funzionare senza caff√®', 'dipendenza caff√®', 'multiple tazze', 'crash caffeina'],
          'pt': ['muito caf√©', 'overdose cafe√≠na', 'n√£o consigo funcionar sem caf√©', 'v√≠cio caf√©', 'm√∫ltiplas x√≠caras', 'crash cafe√≠na'],
          'ru': ['—Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∫–æ—Ñ–µ', '–ø–µ—Ä–µ–¥–æ–∑–∏—Ä–æ–≤–∫–∞ –∫–æ—Ñ–µ–∏–Ω–∞', '–Ω–µ –º–æ–≥—É –±–µ–∑ –∫–æ—Ñ–µ', '–∫–æ—Ñ–µ–π–Ω–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å', '–º–Ω–æ–≥–æ —á–∞—à–µ–∫', '–∫–æ—Ñ–µ–π–Ω—ã–π –∫—Ä–∞—à'],
          'ja': ['„Ç≥„Éº„Éí„ÉºÈ£≤„ÅøÈÅé„Åé', '„Ç´„Éï„Çß„Ç§„É≥ÈÅéÂâ∞ÊëÇÂèñ', '„Ç≥„Éº„Éí„Éº„Å™„Åó„Åß„ÅØÊ©üËÉΩ„Åß„Åç„Å™„ÅÑ', '„Ç≥„Éº„Éí„Éº‰æùÂ≠òÁóá', '‰ΩïÊùØ„ÇÇ', '„Ç´„Éï„Çß„Ç§„É≥„ÇØ„É©„ÉÉ„Ç∑„É•'],
          'ko': ['Ïª§Ìîº ÎÑàÎ¨¥ ÎßéÏù¥', 'Ïπ¥ÌéòÏù∏ Í≥ºÎã§Î≥µÏö©', 'Ïª§Ìîº ÏóÜÏúºÎ©¥ Ïïà Îê®', 'Ïª§Ìîº Ï§ëÎèÖ', 'Ïó¨Îü¨ Ïûî', 'Ïπ¥ÌéòÏù∏ ÌÅ¨ÎûòÏãú'],
          'zh': ['ÂíñÂï°ÂñùÂ§™Â§ö', 'ÂíñÂï°Âõ†ËøáÈáè', 'Ê≤°ÂíñÂï°Êó†Ê≥ïÂ∑•‰Ωú', 'ÂíñÂï°ÊàêÁòæ', 'Â§öÊùØ', 'ÂíñÂï°Âõ†Â¥©Ê∫É'],
          'ar': ['ŸÇŸáŸàÿ© ŸÉÿ´Ÿäÿ±ÿ© ÿ¨ÿØÿßŸã', 'ÿ¨ÿ±ÿπÿ© ÿ≤ÿßÿ¶ÿØÿ© ŸÉÿßŸÅŸäŸäŸÜ', 'ŸÑÿß ÿ£ÿ≥ÿ™ÿ∑Ÿäÿπ ÿßŸÑÿπŸÖŸÑ ÿ®ÿØŸàŸÜ ŸÇŸáŸàÿ©', 'ÿ•ÿØŸÖÿßŸÜ ÿßŸÑŸÇŸáŸàÿ©', 'ÿπÿØÿ© ÿ£ŸÉŸàÿßÿ®', 'ÿßŸÜŸáŸäÿßÿ± ÿßŸÑŸÉÿßŸÅŸäŸäŸÜ'],
          'hi': ['‡§¨‡§π‡•Å‡§§ ‡§ï‡•â‡§´‡•Ä', '‡§ï‡•à‡§´‡•Ä‡§® ‡§ì‡§µ‡§∞‡§°‡•ã‡§ú‡§º', '‡§ï‡•â‡§´‡•Ä ‡§ï‡•á ‡§¨‡§ø‡§®‡§æ ‡§ï‡§æ‡§Æ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ', '‡§ï‡•â‡§´‡•Ä ‡§ï‡•Ä ‡§≤‡§§', '‡§ï‡§à ‡§ï‡§™', '‡§ï‡•à‡§´‡•Ä‡§® ‡§ï‡•ç‡§∞‡•à‡§∂']
        }
      },
      sugar: {
        keywords: {
          'en': ['sugar', 'candy', 'chocolate', 'sweets', 'dessert', 'cake', 'cookies', 'ice cream', 'donuts', 'soda'],
          'nl': ['suiker', 'snoep', 'chocolade', 'zoetigheden', 'dessert', 'taart', 'koekjes', 'ijs', 'donuts', 'frisdrank'],
          'de': ['zucker', 's√º√üigkeiten', 'schokolade', 's√º√ües', 'nachtisch', 'kuchen', 'kekse', 'eis', 'donuts', 'limonade'],
          'fr': ['sucre', 'bonbons', 'chocolat', 'sucreries', 'dessert', 'g√¢teau', 'biscuits', 'glace', 'donuts', 'soda'],
          'es': ['az√∫car', 'dulces', 'chocolate', 'golosinas', 'postre', 'pastel', 'galletas', 'helado', 'rosquillas', 'refresco'],
          'it': ['zucchero', 'caramelle', 'cioccolato', 'dolci', 'dessert', 'torta', 'biscotti', 'gelato', 'ciambelle', 'bibita'],
          'pt': ['a√ß√∫car', 'doces', 'chocolate', 'guloseimas', 'sobremesa', 'bolo', 'biscoitos', 'sorvete', 'rosquinhas', 'refrigerante'],
          'ru': ['—Å–∞—Ö–∞—Ä', '–∫–æ–Ω—Ñ–µ—Ç—ã', '—à–æ–∫–æ–ª–∞–¥', '—Å–ª–∞–¥–æ—Å—Ç–∏', '–¥–µ—Å–µ—Ä—Ç', '—Ç–æ—Ä—Ç', '–ø–µ—á–µ–Ω—å–µ', '–º–æ—Ä–æ–∂–µ–Ω–æ–µ', '–ø–æ–Ω—á–∏–∫–∏', '–≥–∞–∑–∏—Ä–æ–≤–∫–∞'],
          'ja': ['Á†ÇÁ≥ñ', '„ÅäËèìÂ≠ê', '„ÉÅ„Éß„Ç≥„É¨„Éº„Éà', '„Çπ„Ç§„Éº„ÉÑ', '„Éá„Ç∂„Éº„Éà', '„Ç±„Éº„Ç≠', '„ÇØ„ÉÉ„Ç≠„Éº', '„Ç¢„Ç§„Çπ„ÇØ„É™„Éº„É†', '„Éâ„Éº„Éä„ÉÑ', '„ÇΩ„Éº„ÉÄ'],
          'ko': ['ÏÑ§ÌÉï', 'ÏÇ¨ÌÉï', 'Ï¥àÏΩúÎ¶ø', 'Îã®Í≤É', 'ÎîîÏ†ÄÌä∏', 'ÏºÄÏù¥ÌÅ¨', 'Ïø†ÌÇ§', 'ÏïÑÏù¥Ïä§ÌÅ¨Î¶º', 'ÎèÑÎÑõ', 'ÌÉÑÏÇ∞ÏùåÎ£å'],
          'zh': ['Á≥ñ', 'Á≥ñÊûú', 'Â∑ßÂÖãÂäõ', 'ÁîúÈ£ü', 'ÁîúÁÇπ', 'ËõãÁ≥ï', 'È•ºÂπ≤', 'ÂÜ∞Ê∑áÊ∑ã', 'ÁîúÁîúÂúà', 'Ê±ΩÊ∞¥'],
          'ar': ['ÿ≥ŸÉÿ±', 'ÿ≠ŸÑŸàŸäÿßÿ™', 'ÿ¥ŸàŸÉŸàŸÑÿßÿ™ÿ©', 'ÿ≠ŸÑŸàŸâ', 'ÿ≠ŸÑŸâ', 'ŸÉÿπŸÉÿ©', 'ÿ®ÿ≥ŸÉŸàŸäÿ™', 'ÿ¢Ÿäÿ≥ ŸÉÿ±ŸäŸÖ', 'ÿØŸàŸÜÿßÿ™', 'ÿµŸàÿØÿß'],
          'hi': ['‡§ö‡•Ä‡§®‡•Ä', '‡§ï‡•à‡§Ç‡§°‡•Ä', '‡§ö‡•â‡§ï‡§≤‡•á‡§ü', '‡§Æ‡§ø‡§†‡§æ‡§à', '‡§°‡•á‡§∏‡§∞‡•ç‡§ü', '‡§ï‡•á‡§ï', '‡§ï‡•Å‡§ï‡•Ä‡§ú‡§º', '‡§Ü‡§á‡§∏‡§ï‡•ç‡§∞‡•Ä‡§Æ', '‡§°‡•ã‡§®‡§ü‡•ç‡§∏', '‡§∏‡•ã‡§°‡§æ']
        },
        contextPhrases: {
          'en': ['sugar craving', 'ate too much sugar', 'sugar binge', 'couldn\'t resist sweets', 'sugar addiction', 'sugar rush'],
          'nl': ['suiker trek', 'te veel suiker gegeten', 'suiker binge', 'kon zoetigheden niet weerstaan', 'suiker verslaving', 'suiker rush'],
          'de': ['zucker verlangen', 'zu viel zucker gegessen', 'zucker binge', 'konnte s√º√üem nicht widerstehen', 'zucker sucht', 'zucker rausch'],
          'fr': ['envie de sucre', 'trop de sucre mang√©', 'binge sucre', 'n\'ai pas pu r√©sister aux sucreries', 'addiction sucre', 'rush sucre'],
          'es': ['antojo az√∫car', 'comido mucho az√∫car', 'atrac√≥n az√∫car', 'no pude resistir dulces', 'adicci√≥n az√∫car', 'subid√≥n az√∫car'],
          'it': ['voglia zucchero', 'mangiato troppo zucchero', 'binge zucchero', 'non ho resistito ai dolci', 'dipendenza zucchero', 'rush zucchero'],
          'pt': ['vontade a√ß√∫car', 'comi muito a√ß√∫car', 'compuls√£o a√ß√∫car', 'n√£o resisti aos doces', 'v√≠cio a√ß√∫car', 'rush a√ß√∫car'],
          'ru': ['—Ç—è–≥–∞ –∫ —Å–∞—Ö–∞—Ä—É', '—Å—ä–µ–ª –º–Ω–æ–≥–æ —Å–∞—Ö–∞—Ä–∞', '—Å–∞—Ö–∞—Ä–Ω—ã–π –∑–∞–ø–æ–π', '–Ω–µ —Å–º–æ–≥ —É—Å—Ç–æ—è—Ç—å –ø–µ—Ä–µ–¥ —Å–ª–∞–¥–∫–∏–º', '—Å–∞—Ö–∞—Ä–Ω–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å', '—Å–∞—Ö–∞—Ä–Ω—ã–π —Ä—ã–≤–æ–∫'],
          'ja': ['Á†ÇÁ≥ñ„Å∏„ÅÆÊ∏áÊúõ', 'Á†ÇÁ≥ñÊëÇ„ÇäÈÅé„Åé', '„Ç∑„É•„Ç¨„Éº„Éê„Ç§„Éã„É≥„Ç∞', 'Áîò„ÅÑ„ÇÇ„ÅÆ„Å´ÊäµÊäó„Åß„Åç„Å™„Åã„Å£„Åü', 'Á†ÇÁ≥ñ‰æùÂ≠òÁóá', '„Ç∑„É•„Ç¨„Éº„É©„ÉÉ„Ç∑„É•'],
          'ko': ['ÏÑ§ÌÉï Í∞àÎßù', 'ÏÑ§ÌÉï ÎÑàÎ¨¥ ÎßéÏù¥ Î®πÏùå', 'ÏÑ§ÌÉï Ìè≠Ïãù', 'Îã®Í≤ÉÏùÑ Ï∞∏ÏùÑ Ïàò ÏóÜÏóàÎã§', 'ÏÑ§ÌÉï Ï§ëÎèÖ', 'ÏäàÍ∞ÄÎü¨Ïãú'],
          'zh': ['Á≥ñÁòæÂèë‰Ωú', 'ÂêÉÂ§™Â§öÁ≥ñ', 'Á≥ñÂàÜÊö¥È£ü', 'Êó†Ê≥ïÊäóÊãíÁîúÈ£ü', 'Á≥ñÂàÜÊàêÁòæ', 'Á≥ñÂàÜÊøÄÂ¢û'],
          'ar': ['ÿ±ÿ∫ÿ®ÿ© ŸÅŸä ÿßŸÑÿ≥ŸÉÿ±', 'ÿ£ŸÉŸÑÿ™ ÿ≥ŸÉÿ± ŸÉÿ´Ÿäÿ±', 'ŸÜŸáŸÖ ÿßŸÑÿ≥ŸÉÿ±', 'ŸÑŸÖ ÿ£ÿ≥ÿ™ÿ∑ÿπ ŸÖŸÇÿßŸàŸÖÿ© ÿßŸÑÿ≠ŸÑŸàŸäÿßÿ™', 'ÿ•ÿØŸÖÿßŸÜ ÿßŸÑÿ≥ŸÉÿ±', 'ŸÜÿ¥Ÿàÿ© ÿßŸÑÿ≥ŸÉÿ±'],
          'hi': ['‡§ö‡•Ä‡§®‡•Ä ‡§ï‡•Ä ‡§≤‡§æ‡§≤‡§∏‡§æ', '‡§¨‡§π‡•Å‡§§ ‡§ö‡•Ä‡§®‡•Ä ‡§ñ‡§æ‡§à', '‡§∂‡•Å‡§ó‡§∞ ‡§¨‡§ø‡§Ç‡§ú', '‡§Æ‡§ø‡§†‡§æ‡§à ‡§ï‡§æ ‡§µ‡§ø‡§∞‡•ã‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§æ', '‡§ö‡•Ä‡§®‡•Ä ‡§ï‡•Ä ‡§≤‡§§', '‡§∂‡•Å‡§ó‡§∞ ‡§∞‡§∂']
        }
      },
      porn: {
        keywords: {
          'en': ['porn', 'pornography', 'adult content', 'explicit material', 'xxx', 'sexual content', 'adult videos', 'watched porn'],
          'nl': ['porno', 'pornografie', 'volwassen inhoud', 'expliciet materiaal', 'xxx', 'seksuele inhoud', 'volwassen video\'s', 'porno gekeken'],
          'de': ['porno', 'pornografie', 'erwachseneninhalt', 'explizites material', 'xxx', 'sexueller inhalt', 'erwachsenenvideos', 'porno geschaut'],
          'fr': ['porno', 'pornographie', 'contenu adulte', 'mat√©riel explicite', 'xxx', 'contenu sexuel', 'vid√©os adultes', 'regard√© porno'],
          'es': ['porno', 'pornograf√≠a', 'contenido adulto', 'material expl√≠cito', 'xxx', 'contenido sexual', 'videos adultos', 'visto porno'],
          'it': ['porno', 'pornografia', 'contenuto adulto', 'materiale esplicito', 'xxx', 'contenuto sessuale', 'video adulti', 'guardato porno'],
          'pt': ['porno', 'pornografia', 'conte√∫do adulto', 'material expl√≠cito', 'xxx', 'conte√∫do sexual', 'v√≠deos adultos', 'assistiu porno'],
          'ru': ['–ø–æ—Ä–Ω–æ', '–ø–æ—Ä–Ω–æ–≥—Ä–∞—Ñ–∏—è', '–∫–æ–Ω—Ç–µ–Ω—Ç –¥–ª—è –≤–∑—Ä–æ—Å–ª—ã—Ö', '–æ—Ç–∫—Ä–æ–≤–µ–Ω–Ω—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª', 'xxx', '—Å–µ–∫—Å—É–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç', '–≤–∏–¥–µ–æ –¥–ª—è –≤–∑—Ä–æ—Å–ª—ã—Ö', '—Å–º–æ—Ç—Ä–µ–ª –ø–æ—Ä–Ω–æ'],
          'ja': ['„Éù„É´„Éé', '„Éù„É´„Éé„Ç∞„É©„Éï„Ç£„Éº', '„Ç¢„ÉÄ„É´„Éà„Ç≥„É≥„ÉÜ„É≥„ÉÑ', 'Èú≤È™®„Å™Á¥†Êùê', 'xxx', 'ÊÄßÁöÑ„Ç≥„É≥„ÉÜ„É≥„ÉÑ', '„Ç¢„ÉÄ„É´„Éà„Éì„Éá„Ç™', '„Éù„É´„ÉéË¶ã„Åü'],
          'ko': ['Ìè¨Î•¥ÎÖ∏', 'Ìè¨Î•¥ÎÖ∏Í∑∏ÎûòÌîº', 'ÏÑ±Ïù∏ ÏΩòÌÖêÏ∏†', 'ÎÖ∏Í≥®Ï†Å ÏûêÎ£å', 'xxx', 'ÏÑ±Ï†Å ÏΩòÌÖêÏ∏†', 'ÏÑ±Ïù∏ ÎπÑÎîîÏò§', 'Ìè¨Î•¥ÎÖ∏ Î¥§Îã§'],
          'zh': ['Ëâ≤ÊÉÖ', 'Ëâ≤ÊÉÖ‰ΩúÂìÅ', 'Êàê‰∫∫ÂÜÖÂÆπ', 'Èú≤È™®ÊùêÊñô', 'xxx', 'ÊÄßÂÜÖÂÆπ', 'Êàê‰∫∫ËßÜÈ¢ë', 'ÁúãËâ≤ÊÉÖ'],
          'ar': ['ÿ•ÿ®ÿßÿ≠Ÿäÿ©', 'ŸÖŸàÿßÿØ ÿ•ÿ®ÿßÿ≠Ÿäÿ©', 'ŸÖÿ≠ÿ™ŸàŸâ ŸÑŸÑÿ®ÿßŸÑÿ∫ŸäŸÜ', 'ŸÖŸàÿßÿØ ÿµÿ±Ÿäÿ≠ÿ©', 'xxx', 'ŸÖÿ≠ÿ™ŸàŸâ ÿ¨ŸÜÿ≥Ÿä', 'ŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÑŸÑÿ®ÿßŸÑÿ∫ŸäŸÜ', 'ÿ¥ÿßŸáÿØ ÿ•ÿ®ÿßÿ≠Ÿäÿ©'],
          'hi': ['‡§™‡•ã‡§∞‡•ç‡§®', '‡§Ö‡§∂‡•ç‡§≤‡•Ä‡§≤‡§§‡§æ', '‡§µ‡§Ø‡§∏‡•ç‡§ï ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä', '‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä', 'xxx', '‡§Ø‡•å‡§® ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä', '‡§µ‡§Ø‡§∏‡•ç‡§ï ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã', '‡§™‡•ã‡§∞‡•ç‡§® ‡§¶‡•á‡§ñ‡§æ']
        },
        contextPhrases: {
          'en': ['watched pornography', 'adult content relapse', 'couldn\'t resist porn', 'porn addiction relapse', 'explicit material'],
          'nl': ['pornografie gekeken', 'volwassen inhoud terugval', 'kon porno niet weerstaan', 'porno verslaving terugval', 'expliciet materiaal'],
          'de': ['pornografie geschaut', 'erwachseneninhalt r√ºckfall', 'konnte porno nicht widerstehen', 'porno sucht r√ºckfall', 'explizites material'],
          'fr': ['regard√© pornographie', 'rechute contenu adulte', 'n\'ai pas pu r√©sister porno', 'rechute addiction porno', 'mat√©riel explicite'],
          'es': ['visto pornograf√≠a', 'reca√≠da contenido adulto', 'no pude resistir porno', 'reca√≠da adicci√≥n porno', 'material expl√≠cito'],
          'it': ['guardato pornografia', 'ricaduta contenuto adulto', 'non ho resistito porno', 'ricaduta dipendenza porno', 'materiale esplicito'],
          'pt': ['assistiu pornografia', 'reca√≠da conte√∫do adulto', 'n√£o resisti porno', 'reca√≠da v√≠cio porno', 'material expl√≠cito'],
          'ru': ['—Å–º–æ—Ç—Ä–µ–ª –ø–æ—Ä–Ω–æ–≥—Ä–∞—Ñ–∏—é', '—Ä–µ—Ü–∏–¥–∏–≤ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –¥–ª—è –≤–∑—Ä–æ—Å–ª—ã—Ö', '–Ω–µ —Å–º–æ–≥ —É—Å—Ç–æ—è—Ç—å –ø–µ—Ä–µ–¥ –ø–æ—Ä–Ω–æ', '—Ä–µ—Ü–∏–¥–∏–≤ –ø–æ—Ä–Ω–æ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏', '–æ—Ç–∫—Ä–æ–≤–µ–Ω–Ω—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª'],
          'ja': ['„Éù„É´„ÉéË¶ã„Åü', '„Ç¢„ÉÄ„É´„Éà„Ç≥„É≥„ÉÜ„É≥„ÉÑÂÜçÁô∫', '„Éù„É´„Éé„Å´ÊäµÊäó„Åß„Åç„Å™„Åã„Å£„Åü', '„Éù„É´„Éé‰æùÂ≠òÁóáÂÜçÁô∫', 'Èú≤È™®„Å™Á¥†Êùê'],
          'ko': ['Ìè¨Î•¥ÎÖ∏ Î¥§Îã§', 'ÏÑ±Ïù∏ ÏΩòÌÖêÏ∏† Ïû¨Î∞ú', 'Ìè¨Î•¥ÎÖ∏Î•º Ï∞∏ÏùÑ Ïàò ÏóÜÏóàÎã§', 'Ìè¨Î•¥ÎÖ∏ Ï§ëÎèÖ Ïû¨Î∞ú', 'ÎÖ∏Í≥®Ï†Å ÏûêÎ£å'],
          'zh': ['Áúã‰∫ÜËâ≤ÊÉÖ', 'Êàê‰∫∫ÂÜÖÂÆπÂ§çÂèë', 'Êó†Ê≥ïÊäóÊãíËâ≤ÊÉÖ', 'Ëâ≤ÊÉÖÊàêÁòæÂ§çÂèë', 'Èú≤È™®ÊùêÊñô'],
          'ar': ['ÿ¥ÿßŸáÿØ ÿ•ÿ®ÿßÿ≠Ÿäÿ©', 'ÿßŸÜÿ™ŸÉÿßÿ≥ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸÑŸÑÿ®ÿßŸÑÿ∫ŸäŸÜ', 'ŸÑŸÖ ÿ£ÿ≥ÿ™ÿ∑ÿπ ŸÖŸÇÿßŸàŸÖÿ© ÿßŸÑÿ•ÿ®ÿßÿ≠Ÿäÿ©', 'ÿßŸÜÿ™ŸÉÿßÿ≥ ÿ•ÿØŸÖÿßŸÜ ÿßŸÑÿ•ÿ®ÿßÿ≠Ÿäÿ©', 'ŸÖŸàÿßÿØ ÿµÿ±Ÿäÿ≠ÿ©'],
          'hi': ['‡§™‡•ã‡§∞‡•ç‡§® ‡§¶‡•á‡§ñ‡§æ', '‡§µ‡§Ø‡§∏‡•ç‡§ï ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§∞‡§ø‡§≤‡•à‡§™‡•ç‡§∏', '‡§™‡•ã‡§∞‡•ç‡§® ‡§ï‡§æ ‡§µ‡§ø‡§∞‡•ã‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§æ', '‡§™‡•ã‡§∞‡•ç‡§® ‡§è‡§°‡§ø‡§ï‡•ç‡§∂‡§® ‡§∞‡§ø‡§≤‡•à‡§™‡•ç‡§∏', '‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä']
        }
      },
      sex: {
        keywords: {
          'en': ['sex addiction', 'sexual behavior', 'hookup', 'sexual urges', 'sexual compulsion', 'sexual acting out'],
          'nl': ['seks verslaving', 'seksueel gedrag', 'hookup', 'seksuele drang', 'seksuele dwang', 'seksueel uitageren'],
          'de': ['sex sucht', 'sexuelles verhalten', 'hookup', 'sexuelle triebe', 'sexueller zwang', 'sexuelles ausagieren'],
          'fr': ['addiction sexuelle', 'comportement sexuel', 'plan cul', 'pulsions sexuelles', 'compulsion sexuelle', 'passage √† l\'acte sexuel'],
          'es': ['adicci√≥n sexual', 'comportamiento sexual', 'ligue', 'impulsos sexuales', 'compulsi√≥n sexual', 'actuaci√≥n sexual'],
          'it': ['dipendenza sessuale', 'comportamento sessuale', 'avventura', 'impulsi sessuali', 'compulsione sessuale', 'acting out sessuale'],
          'pt': ['v√≠cio sexual', 'comportamento sexual', 'caso', 'impulsos sexuais', 'compuls√£o sexual', 'atua√ß√£o sexual'],
          'ru': ['—Å–µ–∫—Å—É–∞–ª—å–Ω–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å', '—Å–µ–∫—Å—É–∞–ª—å–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ', '—Å–ª—É—á–∞–π–Ω–∞—è —Å–≤—è–∑—å', '—Å–µ–∫—Å—É–∞–ª—å–Ω—ã–µ –≤–ª–µ—á–µ–Ω–∏—è', '—Å–µ–∫—Å—É–∞–ª—å–Ω–∞—è –∫–æ–º–ø—É–ª—å—Å–∏—è', '—Å–µ–∫—Å—É–∞–ª—å–Ω–æ–µ –æ—Ç—ã–≥—Ä—ã–≤–∞–Ω–∏–µ'],
          'ja': ['ÊÄß‰æùÂ≠òÁóá', 'ÊÄßÁöÑË°åÂãï', '„ÉØ„É≥„Éä„Ç§„Éà„Çπ„Çø„É≥„Éâ', 'ÊÄßÁöÑË°ùÂãï', 'ÊÄßÁöÑÂº∑Ëø´', 'ÊÄßÁöÑÈÄ∏ËÑ±Ë°åÁÇ∫'],
          'ko': ['ÏÑ±Ï§ëÎèÖ', 'ÏÑ±Ï†Å ÌñâÎèô', 'ÏõêÎÇòÏûá', 'ÏÑ±Ï†Å Ï∂©Îèô', 'ÏÑ±Ï†Å Í∞ïÎ∞ï', 'ÏÑ±Ï†Å ÏùºÌÉà'],
          'zh': ['ÊÄßÁòæ', 'ÊÄßË°å‰∏∫', '‰∏ÄÂ§úÊÉÖ', 'ÊÄßÂÜ≤Âä®', 'ÊÄßÂº∫Ëø´', 'ÊÄßË°å‰∏∫Â§±Êéß'],
          'ar': ['ÿ•ÿØŸÖÿßŸÜ ÿ¨ŸÜÿ≥Ÿä', 'ÿ≥ŸÑŸàŸÉ ÿ¨ŸÜÿ≥Ÿä', 'ÿπŸÑÿßŸÇÿ© ÿπÿßÿ®ÿ±ÿ©', 'ÿØŸàÿßŸÅÿπ ÿ¨ŸÜÿ≥Ÿäÿ©', 'ÿ•ÿ¨ÿ®ÿßÿ± ÿ¨ŸÜÿ≥Ÿä', 'ÿ™ÿµÿ±ŸÅ ÿ¨ŸÜÿ≥Ÿä'],
          'hi': ['‡§Ø‡•å‡§® ‡§≤‡§§', '‡§Ø‡•å‡§® ‡§µ‡•ç‡§Ø‡§µ‡§π‡§æ‡§∞', '‡§π‡•Å‡§ï‡§Ö‡§™', '‡§Ø‡•å‡§® ‡§á‡§ö‡•ç‡§õ‡§æ‡§è‡§Ç', '‡§Ø‡•å‡§® ‡§¨‡§æ‡§ß‡•ç‡§Ø‡§§‡§æ', '‡§Ø‡•å‡§® ‡§Ö‡§≠‡§ø‡§®‡§Ø']
        },
        contextPhrases: {
          'en': ['sexual relapse', 'acting out sexually', 'compulsive sexual behavior', 'sexual addiction episode', 'inappropriate sexual contact'],
          'nl': ['seksuele terugval', 'seksueel uitageren', 'dwangmatig seksueel gedrag', 'seksuele verslaving episode', 'ongepast seksueel contact'],
          'de': ['sexueller r√ºckfall', 'sexuell ausagieren', 'zwanghaftes sexuelles verhalten', 'sexuelle sucht episode', 'unangemessener sexueller kontakt'],
          'fr': ['rechute sexuelle', 'passage √† l\'acte sexuel', 'comportement sexuel compulsif', '√©pisode addiction sexuelle', 'contact sexuel inappropri√©'],
          'es': ['reca√≠da sexual', 'actuaci√≥n sexual', 'comportamiento sexual compulsivo', 'episodio adicci√≥n sexual', 'contacto sexual inapropiado'],
          'it': ['ricaduta sessuale', 'acting out sessuale', 'comportamento sessuale compulsivo', 'episodio dipendenza sessuale', 'contatto sessuale inappropriato'],
          'pt': ['reca√≠da sexual', 'atua√ß√£o sexual', 'comportamento sexual compulsivo', 'epis√≥dio v√≠cio sexual', 'contato sexual inadequado'],
          'ru': ['—Å–µ–∫—Å—É–∞–ª—å–Ω—ã–π —Ä–µ—Ü–∏–¥–∏–≤', '—Å–µ–∫—Å—É–∞–ª—å–Ω–æ–µ –æ—Ç—ã–≥—Ä—ã–≤–∞–Ω–∏–µ', '–∫–æ–º–ø—É–ª—å—Å–∏–≤–Ω–æ–µ —Å–µ–∫—Å—É–∞–ª—å–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ', '—ç–ø–∏–∑–æ–¥ —Å–µ–∫—Å—É–∞–ª—å–Ω–æ–π –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏', '–Ω–µ–ø–æ–¥–æ–±–∞—é—â–∏–π —Å–µ–∫—Å—É–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–∞–∫—Ç'],
          'ja': ['ÊÄßÁöÑÂÜçÁô∫', 'ÊÄßÁöÑÈÄ∏ËÑ±Ë°åÁÇ∫', 'Âº∑Ëø´ÁöÑÊÄßË°åÂãï', 'ÊÄß‰æùÂ≠òÁóá„Ç®„Éî„ÇΩ„Éº„Éâ', '‰∏çÈÅ©Âàá„Å™ÊÄßÁöÑÊé•Ëß¶'],
          'ko': ['ÏÑ±Ï†Å Ïû¨Î∞ú', 'ÏÑ±Ï†Å ÏùºÌÉà', 'Í∞ïÎ∞ïÏ†Å ÏÑ±ÌñâÎèô', 'ÏÑ±Ï§ëÎèÖ ÏóêÌîºÏÜåÎìú', 'Î∂ÄÏ†ÅÏ†àÌïú ÏÑ±Ï†Å Ï†ëÏ¥â'],
          'zh': ['ÊÄßË°å‰∏∫Â§çÂèë', 'ÊÄßË°å‰∏∫Â§±Êéß', 'Âº∫Ëø´ÊÄßË°å‰∏∫', 'ÊÄßÁòæÂèë‰Ωú', '‰∏çÂΩìÊÄßÊé•Ëß¶'],
          'ar': ['ÿßŸÜÿ™ŸÉÿßÿ≥ ÿ¨ŸÜÿ≥Ÿä', 'ÿ™ÿµÿ±ŸÅ ÿ¨ŸÜÿ≥Ÿä', 'ÿ≥ŸÑŸàŸÉ ÿ¨ŸÜÿ≥Ÿä ŸÇŸáÿ±Ÿä', 'ŸÜŸàÿ®ÿ© ÿ•ÿØŸÖÿßŸÜ ÿ¨ŸÜÿ≥Ÿä', 'ÿßÿ™ÿµÿßŸÑ ÿ¨ŸÜÿ≥Ÿä ÿ∫Ÿäÿ± ŸÖŸÜÿßÿ≥ÿ®'],
          'hi': ['‡§Ø‡•å‡§® ‡§∞‡§ø‡§≤‡•à‡§™‡•ç‡§∏', '‡§Ø‡•å‡§® ‡§Ö‡§≠‡§ø‡§®‡§Ø', '‡§¨‡§æ‡§ß‡•ç‡§Ø‡§ï‡§æ‡§∞‡•Ä ‡§Ø‡•å‡§® ‡§µ‡•ç‡§Ø‡§µ‡§π‡§æ‡§∞', '‡§Ø‡•å‡§® ‡§≤‡§§ ‡§è‡§™‡§ø‡§∏‡•ã‡§°', '‡§Ö‡§®‡•Å‡§ö‡§ø‡§§ ‡§Ø‡•å‡§® ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï']
        }
      },
      work: {
        keywords: {
          'en': ['workaholic', 'overwork', 'work addiction', 'can\'t stop working', 'work obsession', 'burnout'],
          'nl': ['workaholic', 'overwerken', 'werk verslaving', 'kan niet stoppen met werken', 'werk obsessie', 'burn-out'],
          'de': ['workaholic', '√ºberarbeitung', 'arbeits sucht', 'kann nicht aufh√∂ren zu arbeiten', 'arbeits obsession', 'burnout'],
          'fr': ['workaholic', 'surmenage', 'addiction travail', 'ne peux pas arr√™ter travailler', 'obsession travail', 'burnout'],
          'es': ['workaholic', 'exceso trabajo', 'adicci√≥n trabajo', 'no puedo parar trabajar', 'obsesi√≥n trabajo', 'burnout'],
          'it': ['workaholic', 'superlavoro', 'dipendenza lavoro', 'non riesco smettere lavorare', 'ossessione lavoro', 'burnout'],
          'pt': ['workaholic', 'excesso trabalho', 'v√≠cio trabalho', 'n√£o consigo parar trabalhar', 'obsess√£o trabalho', 'burnout'],
          'ru': ['—Ç—Ä—É–¥–æ–≥–æ–ª–∏–∫', '–ø–µ—Ä–µ—Ä–∞–±–æ—Ç–∫–∞', '—Ç—Ä—É–¥–æ–≤–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å', '–Ω–µ –º–æ–≥—É –ø–µ—Ä–µ—Å—Ç–∞—Ç—å —Ä–∞–±–æ—Ç–∞—Ç—å', '–æ–¥–µ—Ä–∂–∏–º–æ—Å—Ç—å —Ä–∞–±–æ—Ç–æ–π', '–≤—ã–≥–æ—Ä–∞–Ω–∏–µ'],
          'ja': ['„ÉØ„Éº„Ç´„Éõ„É™„ÉÉ„ÇØ', 'ÈÅéÂä¥', '‰ªï‰∫ã‰∏≠ÊØí', 'ÂÉç„Åè„ÅÆ„Çí„ÇÑ„ÇÅ„Çâ„Çå„Å™„ÅÑ', '‰ªï‰∫ã„Å∏„ÅÆÂü∑ÁùÄ', 'ÁáÉ„ÅàÂ∞Ω„ÅçÁóáÂÄôÁæ§'],
          'ko': ['ÏõåÏª§ÌôÄÎ¶≠', 'Í≥ºÎ°ú', 'Ïùº Ï§ëÎèÖ', 'ÏùºÏùÑ Î©àÏ∂ú Ïàò ÏóÜÎã§', 'Ïùº Í∞ïÎ∞ï', 'Î≤àÏïÑÏõÉ'],
          'zh': ['Â∑•‰ΩúÁãÇ', 'ËøáÂ∫¶Â∑•‰Ωú', 'Â∑•‰ΩúÊàêÁòæ', 'ÂÅú‰∏ç‰∏ãÊù•Â∑•‰Ωú', 'Â∑•‰ΩúÂº∫Ëø´Áóá', 'ËÅå‰∏öÂÄ¶ÊÄ†'],
          'ar': ['ŸÖÿØŸÖŸÜ ÿπŸÖŸÑ', 'ÿ•ŸÅÿ±ÿßÿ∑ ÿπŸÖŸÑ', 'ÿ•ÿØŸÖÿßŸÜ ÿßŸÑÿπŸÖŸÑ', 'ŸÑÿß ÿ£ÿ≥ÿ™ÿ∑Ÿäÿπ ÿßŸÑÿ™ŸàŸÇŸÅ ÿπŸÜ ÿßŸÑÿπŸÖŸÑ', 'ŸáŸàÿ≥ ÿßŸÑÿπŸÖŸÑ', 'ÿßÿ≠ÿ™ÿ±ÿßŸÇ Ÿàÿ∏ŸäŸÅŸä'],
          'hi': ['‡§µ‡§∞‡•ç‡§ï‡§π‡•â‡§≤‡§ø‡§ï', '‡§Ö‡§ß‡§ø‡§ï ‡§ï‡§æ‡§Æ', '‡§ï‡§æ‡§Æ ‡§ï‡•Ä ‡§≤‡§§', '‡§ï‡§æ‡§Æ ‡§¨‡§Ç‡§¶ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ', '‡§ï‡§æ‡§Æ ‡§ï‡§æ ‡§ú‡•Å‡§®‡•Ç‡§®', '‡§¨‡§∞‡•ç‡§®‡§Ü‡§â‡§ü']
        },
        contextPhrases: {
          'en': ['worked too much', 'couldn\'t stop working', 'work addiction relapse', 'overworking again', 'work obsession episode'],
          'nl': ['te veel gewerkt', 'kon niet stoppen met werken', 'werk verslaving terugval', 'weer overwerken', 'werk obsessie episode'],
          'de': ['zu viel gearbeitet', 'konnte nicht aufh√∂ren zu arbeiten', 'arbeits sucht r√ºckfall', 'wieder √ºberarbeitung', 'arbeits obsession episode'],
          'fr': ['trop travaill√©', 'n\'ai pas pu arr√™ter travailler', 'rechute addiction travail', 'surmenage encore', '√©pisode obsession travail'],
          'es': ['trabajado demasiado', 'no pude parar trabajar', 'reca√≠da adicci√≥n trabajo', 'exceso trabajo otra vez', 'episodio obsesi√≥n trabajo'],
          'it': ['lavorato troppo', 'non riuscivo smettere lavorare', 'ricaduta dipendenza lavoro', 'superlavoro ancora', 'episodio ossessione lavoro'],
          'pt': ['trabalhei demais', 'n√£o consegui parar trabalhar', 'reca√≠da v√≠cio trabalho', 'excesso trabalho novamente', 'epis√≥dio obsess√£o trabalho'],
          'ru': ['—Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —Ä–∞–±–æ—Ç–∞–ª', '–Ω–µ –º–æ–≥ –ø–µ—Ä–µ—Å—Ç–∞—Ç—å —Ä–∞–±–æ—Ç–∞—Ç—å', '—Ä–µ—Ü–∏–¥–∏–≤ —Ç—Ä—É–¥–æ–≤–æ–π –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏', '—Å–Ω–æ–≤–∞ –ø–µ—Ä–µ—Ä–∞–±–æ—Ç–∫–∞', '—ç–ø–∏–∑–æ–¥ –æ–¥–µ—Ä–∂–∏–º–æ—Å—Ç–∏ —Ä–∞–±–æ—Ç–æ–π'],
          'ja': ['ÂÉç„ÅçÈÅé„Åé„Åü', 'ÂÉç„Åè„ÅÆ„Çí„ÇÑ„ÇÅ„Çâ„Çå„Å™„Åã„Å£„Åü', '‰ªï‰∫ã‰∏≠ÊØíÂÜçÁô∫', '„Åæ„ÅüÈÅéÂä¥', '‰ªï‰∫ã„Å∏„ÅÆÂü∑ÁùÄ„Ç®„Éî„ÇΩ„Éº„Éâ'],
          'ko': ['ÎÑàÎ¨¥ ÎßéÏù¥ ÏùºÌñàÎã§', 'ÏùºÏùÑ Î©àÏ∂ú Ïàò ÏóÜÏóàÎã§', 'Ïùº Ï§ëÎèÖ Ïû¨Î∞ú', 'Îã§Ïãú Í≥ºÎ°ú', 'Ïùº Í∞ïÎ∞ï ÏóêÌîºÏÜåÎìú'],
          'zh': ['Â∑•‰ΩúÂ§™Â§ö', 'ÂÅú‰∏ç‰∏ãÊù•Â∑•‰Ωú', 'Â∑•‰ΩúÊàêÁòæÂ§çÂèë', 'ÂèàËøáÂ∫¶Â∑•‰Ωú', 'Â∑•‰ΩúÂº∫Ëø´ÁóáÂèë‰Ωú'],
          'ar': ['ÿπŸÖŸÑÿ™ ŸÉÿ´Ÿäÿ±ÿßŸã', 'ŸÑŸÖ ÿ£ÿ≥ÿ™ÿ∑ÿπ ÿßŸÑÿ™ŸàŸÇŸÅ ÿπŸÜ ÿßŸÑÿπŸÖŸÑ', 'ÿßŸÜÿ™ŸÉÿßÿ≥ ÿ•ÿØŸÖÿßŸÜ ÿßŸÑÿπŸÖŸÑ', 'ÿ•ŸÅÿ±ÿßÿ∑ ÿπŸÖŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ', 'ŸÜŸàÿ®ÿ© ŸáŸàÿ≥ ÿßŸÑÿπŸÖŸÑ'],
          'hi': ['‡§¨‡§π‡•Å‡§§ ‡§ï‡§æ‡§Æ ‡§ï‡§ø‡§Ø‡§æ', '‡§ï‡§æ‡§Æ ‡§¨‡§Ç‡§¶ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§æ', '‡§ï‡§æ‡§Æ ‡§ï‡•Ä ‡§≤‡§§ ‡§∞‡§ø‡§≤‡•à‡§™‡•ç‡§∏', '‡§´‡§ø‡§∞ ‡§∏‡•á ‡§Ö‡§ß‡§ø‡§ï ‡§ï‡§æ‡§Æ', '‡§ï‡§æ‡§Æ ‡§ï‡•á ‡§ú‡•Å‡§®‡•Ç‡§® ‡§ï‡§æ ‡§è‡§™‡§ø‡§∏‡•ã‡§°']
        }
      },
      exercise: {
        keywords: {
          'en': ['exercise addiction', 'overtraining', 'compulsive exercise', 'gym addiction', 'workout obsession', 'fitness obsession'],
          'nl': ['sport verslaving', 'overtraining', 'dwangmatige sport', 'gym verslaving', 'workout obsessie', 'fitness obsessie'],
          'de': ['sport sucht', '√ºbertraining', 'zwanghafter sport', 'fitnessstudio sucht', 'workout obsession', 'fitness obsession'],
          'fr': ['addiction exercice', 'surentra√Ænement', 'exercice compulsif', 'addiction gym', 'obsession entra√Ænement', 'obsession fitness'],
          'es': ['adicci√≥n ejercicio', 'sobreentrenamiento', 'ejercicio compulsivo', 'adicci√≥n gym', 'obsesi√≥n entrenamiento', 'obsesi√≥n fitness'],
          'it': ['dipendenza esercizio', 'sovrallenamento', 'esercizio compulsivo', 'dipendenza palestra', 'ossessione allenamento', 'ossessione fitness'],
          'pt': ['v√≠cio exerc√≠cio', 'overtraining', 'exerc√≠cio compulsivo', 'v√≠cio academia', 'obsess√£o treino', 'obsess√£o fitness'],
          'ru': ['–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π', '–ø–µ—Ä–µ—Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç—å', '–∫–æ–º–ø—É–ª—å—Å–∏–≤–Ω—ã–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è', '–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç —Å–ø–æ—Ä—Ç–∑–∞–ª–∞', '–æ–¥–µ—Ä–∂–∏–º–æ—Å—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞–º–∏', '–æ–¥–µ—Ä–∂–∏–º–æ—Å—Ç—å —Ñ–∏—Ç–Ω–µ—Å–æ–º'],
          'ja': ['ÈÅãÂãï‰æùÂ≠òÁóá', '„Ç™„Éº„Éê„Éº„Éà„É¨„Éº„Éã„É≥„Ç∞', 'Âº∑Ëø´ÁöÑÈÅãÂãï', '„Ç∏„É†‰æùÂ≠òÁóá', '„ÉØ„Éº„ÇØ„Ç¢„Ç¶„Éà‰æùÂ≠ò', '„Éï„Ç£„ÉÉ„Éà„Éç„Çπ‰æùÂ≠ò'],
          'ko': ['Ïö¥Îèô Ï§ëÎèÖ', 'Í≥ºÌõàÎ†®', 'Í∞ïÎ∞ïÏ†Å Ïö¥Îèô', 'Ìó¨Ïä§Ïû• Ï§ëÎèÖ', 'Ïö¥Îèô Í∞ïÎ∞ï', 'ÌîºÌä∏ÎãàÏä§ Í∞ïÎ∞ï'],
          'zh': ['ËøêÂä®ÊàêÁòæ', 'ËøáÂ∫¶ËÆ≠ÁªÉ', 'Âº∫Ëø´ÊÄßËøêÂä®', 'ÂÅ•Ë∫´ÊàøÊàêÁòæ', 'ÈîªÁÇºÂº∫Ëø´Áóá', 'ÂÅ•Ë∫´Âº∫Ëø´Áóá'],
          'ar': ['ÿ•ÿØŸÖÿßŸÜ ÿßŸÑÿ™ŸÖÿßÿ±ŸäŸÜ', 'ÿ•ŸÅÿ±ÿßÿ∑ ÿ™ÿØÿ±Ÿäÿ®', 'ÿ™ŸÖÿßÿ±ŸäŸÜ ŸÇŸáÿ±Ÿäÿ©', 'ÿ•ÿØŸÖÿßŸÜ ÿßŸÑÿ¨ŸäŸÖ', 'ŸáŸàÿ≥ ÿßŸÑÿ™ÿØÿ±Ÿäÿ®', 'ŸáŸàÿ≥ ÿßŸÑŸÑŸäÿßŸÇÿ©'],
          'hi': ['‡§µ‡•ç‡§Ø‡§æ‡§Ø‡§æ‡§Æ ‡§ï‡•Ä ‡§≤‡§§', '‡§Ö‡§ß‡§ø‡§ï ‡§™‡•ç‡§∞‡§∂‡§ø‡§ï‡•ç‡§∑‡§£', '‡§¨‡§æ‡§ß‡•ç‡§Ø‡§ï‡§æ‡§∞‡•Ä ‡§µ‡•ç‡§Ø‡§æ‡§Ø‡§æ‡§Æ', '‡§ú‡§ø‡§Æ ‡§ï‡•Ä ‡§≤‡§§', '‡§µ‡§∞‡•ç‡§ï‡§Ü‡§â‡§ü ‡§ï‡§æ ‡§ú‡•Å‡§®‡•Ç‡§®', '‡§´‡§ø‡§ü‡§®‡•á‡§∏ ‡§ï‡§æ ‡§ú‡•Å‡§®‡•Ç‡§®']
        },
        contextPhrases: {
          'en': ['exercised excessively', 'couldn\'t skip workout', 'exercise addiction relapse', 'overtraining episode', 'compulsive gym session'],
          'nl': ['excessief gesport', 'kon training niet overslaan', 'sport verslaving terugval', 'overtraining episode', 'dwangmatige gym sessie'],
          'de': ['excessiv trainiert', 'konnte training nicht auslassen', 'sport sucht r√ºckfall', '√ºbertraining episode', 'zwanghafte gym session'],
          'fr': ['exercice excessif', 'n\'ai pas pu rater entra√Ænement', 'rechute addiction exercice', '√©pisode surentra√Ænement', 's√©ance gym compulsive'],
          'es': ['ejercicio excesivo', 'no pude faltar entrenamiento', 'reca√≠da adicci√≥n ejercicio', 'episodio sobreentrenamiento', 'sesi√≥n gym compulsiva'],
          'it': ['esercizio eccessivo', 'non potevo saltare allenamento', 'ricaduta dipendenza esercizio', 'episodio sovrallenamento', 'sessione palestra compulsiva'],
          'pt': ['exerc√≠cio excessivo', 'n√£o pude pular treino', 'reca√≠da v√≠cio exerc√≠cio', 'epis√≥dio overtraining', 'sess√£o academia compulsiva'],
          'ru': ['—á—Ä–µ–∑–º–µ—Ä–Ω—ã–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è', '–Ω–µ –º–æ–≥ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É', '—Ä–µ—Ü–∏–¥–∏–≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π', '—ç–ø–∏–∑–æ–¥ –ø–µ—Ä–µ—Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏', '–∫–æ–º–ø—É–ª—å—Å–∏–≤–Ω–∞—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞'],
          'ja': ['ÈÅéÂ∫¶„Å™ÈÅãÂãï', '„ÉØ„Éº„ÇØ„Ç¢„Ç¶„Éà„Çí„Çπ„Ç≠„ÉÉ„Éó„Åß„Åç„Å™„Åã„Å£„Åü', 'ÈÅãÂãï‰æùÂ≠òÁóáÂÜçÁô∫', '„Ç™„Éº„Éê„Éº„Éà„É¨„Éº„Éã„É≥„Ç∞„Ç®„Éî„ÇΩ„Éº„Éâ', 'Âº∑Ëø´ÁöÑ„Ç∏„É†„Çª„ÉÉ„Ç∑„Éß„É≥'],
          'ko': ['Í≥ºÎèÑÌïú Ïö¥Îèô', 'Ïö¥ÎèôÏùÑ ÎπºÎ®πÏùÑ Ïàò ÏóÜÏóàÎã§', 'Ïö¥Îèô Ï§ëÎèÖ Ïû¨Î∞ú', 'Í≥ºÌõàÎ†® ÏóêÌîºÏÜåÎìú', 'Í∞ïÎ∞ïÏ†Å Ìó¨Ïä§Ïû• ÏÑ∏ÏÖò'],
          'zh': ['ËøáÂ∫¶ËøêÂä®', '‰∏çËÉΩË∑≥ËøáÈîªÁÇº', 'ËøêÂä®ÊàêÁòæÂ§çÂèë', 'ËøáÂ∫¶ËÆ≠ÁªÉÂèë‰Ωú', 'Âº∫Ëø´ÊÄßÂÅ•Ë∫´ÊàøËÆ≠ÁªÉ'],
          'ar': ['ÿ™ŸÖÿßÿ±ŸäŸÜ ŸÖŸÅÿ±ÿ∑ÿ©', 'ŸÑŸÖ ÿ£ÿ≥ÿ™ÿ∑ÿπ ÿ™ŸÅŸàŸäÿ™ ÿßŸÑÿ™ŸÖÿ±ŸäŸÜ', 'ÿßŸÜÿ™ŸÉÿßÿ≥ ÿ•ÿØŸÖÿßŸÜ ÿßŸÑÿ™ŸÖÿßÿ±ŸäŸÜ', 'ŸÜŸàÿ®ÿ© ÿ•ŸÅÿ±ÿßÿ∑ ÿ™ÿØÿ±Ÿäÿ®', 'ÿ¨ŸÑÿ≥ÿ© ÿ¨ŸäŸÖ ŸÇŸáÿ±Ÿäÿ©'],
          'hi': ['‡§Ö‡§§‡•ç‡§Ø‡§ß‡§ø‡§ï ‡§µ‡•ç‡§Ø‡§æ‡§Ø‡§æ‡§Æ', '‡§µ‡§∞‡•ç‡§ï‡§Ü‡§â‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§õ‡•ã‡§°‡§º ‡§∏‡§ï‡§§‡§æ ‡§•‡§æ', '‡§µ‡•ç‡§Ø‡§æ‡§Ø‡§æ‡§Æ ‡§ï‡•Ä ‡§≤‡§§ ‡§∞‡§ø‡§≤‡•à‡§™‡•ç‡§∏', '‡§Ö‡§ß‡§ø‡§ï ‡§™‡•ç‡§∞‡§∂‡§ø‡§ï‡•ç‡§∑‡§£ ‡§è‡§™‡§ø‡§∏‡•ã‡§°', '‡§¨‡§æ‡§ß‡•ç‡§Ø‡§ï‡§æ‡§∞‡•Ä ‡§ú‡§ø‡§Æ ‡§∏‡•á‡§∂‡§®']
        }
      },
      phone: {
        keywords: {
          'en': ['phone addiction', 'smartphone', 'screen time', 'mobile addiction', 'can\'t put phone down', 'phone checking'],
          'nl': ['telefoon verslaving', 'smartphone', 'schermtijd', 'mobiele verslaving', 'kan telefoon niet wegleggen', 'telefoon checken'],
          'de': ['handy sucht', 'smartphone', 'bildschirmzeit', 'mobile sucht', 'kann handy nicht weglegen', 'handy checken'],
          'fr': ['addiction t√©l√©phone', 'smartphone', 'temps √©cran', 'addiction mobile', 'ne peux pas l√¢cher t√©l√©phone', 'v√©rifier t√©l√©phone'],
          'es': ['adicci√≥n tel√©fono', 'smartphone', 'tiempo pantalla', 'adicci√≥n m√≥vil', 'no puedo soltar tel√©fono', 'revisar tel√©fono'],
          'it': ['dipendenza telefono', 'smartphone', 'tempo schermo', 'dipendenza mobile', 'non riesco lasciare telefono', 'controllare telefono'],
          'pt': ['v√≠cio telefone', 'smartphone', 'tempo tela', 'v√≠cio m√≥vel', 'n√£o consigo largar telefone', 'checar telefone'],
          'ru': ['–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç —Ç–µ–ª–µ—Ñ–æ–Ω–∞', '—Å–º–∞—Ä—Ç—Ñ–æ–Ω', '—ç–∫—Ä–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è', '–º–æ–±–∏–ª—å–Ω–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å', '–Ω–µ –º–æ–≥—É –æ—Ç–ª–æ–∂–∏—Ç—å —Ç–µ–ª–µ—Ñ–æ–Ω', '–ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞'],
          'ja': ['„Çπ„Éû„Éõ‰æùÂ≠òÁóá', '„Çπ„Éû„Éº„Éà„Éï„Ç©„É≥', '„Çπ„ÇØ„É™„Éº„É≥„Çø„Ç§„É†', '„É¢„Éê„Ç§„É´‰æùÂ≠òÁóá', '„Çπ„Éû„Éõ„ÇíÊâãÊîæ„Åõ„Å™„ÅÑ', '„Çπ„Éû„Éõ„ÉÅ„Çß„ÉÉ„ÇØ'],
          'ko': ['Ìè∞ Ï§ëÎèÖ', 'Ïä§ÎßàÌä∏Ìè∞', 'ÌôîÎ©¥ ÏãúÍ∞Ñ', 'Î™®Î∞îÏùº Ï§ëÎèÖ', 'Ìè∞ÏùÑ ÎÇ¥Î†§ÎÜìÏùÑ Ïàò ÏóÜÎã§', 'Ìè∞ Ï≤¥ÌÅ¨'],
          'zh': ['ÊâãÊú∫ÊàêÁòæ', 'Êô∫ËÉΩÊâãÊú∫', 'Â±èÂπïÊó∂Èó¥', 'ÁßªÂä®ËÆæÂ§áÊàêÁòæ', 'Êîæ‰∏ç‰∏ãÊâãÊú∫', 'Ê£ÄÊü•ÊâãÊú∫'],
          'ar': ['ÿ•ÿØŸÖÿßŸÜ ÿßŸÑŸáÿßÿ™ŸÅ', 'Ÿáÿßÿ™ŸÅ ÿ∞ŸÉŸä', 'ŸàŸÇÿ™ ÿßŸÑÿ¥ÿßÿ¥ÿ©', 'ÿ•ÿØŸÖÿßŸÜ ÿßŸÑÿ¨ŸàÿßŸÑ', 'ŸÑÿß ÿ£ÿ≥ÿ™ÿ∑Ÿäÿπ ÿ™ÿ±ŸÉ ÿßŸÑŸáÿßÿ™ŸÅ', 'ŸÅÿ≠ÿµ ÿßŸÑŸáÿßÿ™ŸÅ'],
          'hi': ['‡§´‡•ã‡§® ‡§ï‡•Ä ‡§≤‡§§', '‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü‡§´‡•ã‡§®', '‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§® ‡§ü‡§æ‡§á‡§Æ', '‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§≤‡§§', '‡§´‡•ã‡§® ‡§®‡§π‡•Ä‡§Ç ‡§õ‡•ã‡§°‡§º ‡§∏‡§ï‡§§‡§æ', '‡§´‡•ã‡§® ‡§ö‡•á‡§ï‡§ø‡§Ç‡§ó']
        },
        contextPhrases: {
          'en': ['hours on phone', 'couldn\'t put phone down', 'phone addiction relapse', 'excessive screen time', 'compulsive phone checking'],
          'nl': ['uren op telefoon', 'kon telefoon niet wegleggen', 'telefoon verslaving terugval', 'excessieve schermtijd', 'dwangmatig telefoon checken'],
          'de': ['stunden am handy', 'konnte handy nicht weglegen', 'handy sucht r√ºckfall', 'exzessive bildschirmzeit', 'zwanghaftes handy checken'],
          'fr': ['heures sur t√©l√©phone', 'n\'ai pas pu l√¢cher t√©l√©phone', 'rechute addiction t√©l√©phone', 'temps √©cran excessif', 'v√©rification t√©l√©phone compulsive'],
          'es': ['horas en tel√©fono', 'no pude soltar tel√©fono', 'reca√≠da adicci√≥n tel√©fono', 'tiempo pantalla excesivo', 'revisi√≥n tel√©fono compulsiva'],
          'it': ['ore al telefono', 'non riuscivo lasciare telefono', 'ricaduta dipendenza telefono', 'tempo schermo eccessivo', 'controllo telefono compulsivo'],
          'pt': ['horas no telefone', 'n√£o consegui largar telefone', 'reca√≠da v√≠cio telefone', 'tempo tela excessivo', 'checagem telefone compulsiva'],
          'ru': ['—á–∞—Å—ã –≤ —Ç–µ–ª–µ—Ñ–æ–Ω–µ', '–Ω–µ –º–æ–≥ –æ—Ç–ª–æ–∂–∏—Ç—å —Ç–µ–ª–µ—Ñ–æ–Ω', '—Ä–µ—Ü–∏–¥–∏–≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–µ–ª–µ—Ñ–æ–Ω–∞', '—á—Ä–µ–∑–º–µ—Ä–Ω–æ–µ —ç–∫—Ä–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è', '–∫–æ–º–ø—É–ª—å—Å–∏–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞'],
          'ja': ['‰ΩïÊôÇÈñì„ÇÇ„Çπ„Éû„Éõ', '„Çπ„Éû„Éõ„ÇíÊâãÊîæ„Åõ„Å™„Åã„Å£„Åü', '„Çπ„Éû„Éõ‰æùÂ≠òÁóáÂÜçÁô∫', 'ÈÅéÂ∫¶„Å™„Çπ„ÇØ„É™„Éº„É≥„Çø„Ç§„É†', 'Âº∑Ëø´ÁöÑ„Çπ„Éû„Éõ„ÉÅ„Çß„ÉÉ„ÇØ'],
          'ko': ['Î™á ÏãúÍ∞Ñ Ìè∞ ÏÇ¨Ïö©', 'Ìè∞ÏùÑ ÎÇ¥Î†§ÎÜìÏùÑ Ïàò ÏóÜÏóàÎã§', 'Ìè∞ Ï§ëÎèÖ Ïû¨Î∞ú', 'Í≥ºÎèÑÌïú ÌôîÎ©¥ ÏãúÍ∞Ñ', 'Í∞ïÎ∞ïÏ†Å Ìè∞ Ï≤¥ÌÅ¨'],
          'zh': ['Âá†Â∞èÊó∂Áé©ÊâãÊú∫', 'Êîæ‰∏ç‰∏ãÊâãÊú∫', 'ÊâãÊú∫ÊàêÁòæÂ§çÂèë', 'ËøáÂ∫¶Â±èÂπïÊó∂Èó¥', 'Âº∫Ëø´ÊÄßÊ£ÄÊü•ÊâãÊú∫'],
          'ar': ['ÿ≥ÿßÿπÿßÿ™ ÿπŸÑŸâ ÿßŸÑŸáÿßÿ™ŸÅ', 'ŸÑŸÖ ÿ£ÿ≥ÿ™ÿ∑ÿπ ÿ™ÿ±ŸÉ ÿßŸÑŸáÿßÿ™ŸÅ', 'ÿßŸÜÿ™ŸÉÿßÿ≥ ÿ•ÿØŸÖÿßŸÜ ÿßŸÑŸáÿßÿ™ŸÅ', 'ŸàŸÇÿ™ ÿ¥ÿßÿ¥ÿ© ŸÖŸÅÿ±ÿ∑', 'ŸÅÿ≠ÿµ ÿßŸÑŸáÿßÿ™ŸÅ ÿßŸÑŸÇŸáÿ±Ÿä'],
          'hi': ['‡§ò‡§Ç‡§ü‡•ã‡§Ç ‡§´‡•ã‡§® ‡§™‡§∞', '‡§´‡•ã‡§® ‡§®‡§π‡•Ä‡§Ç ‡§õ‡•ã‡§°‡§º ‡§∏‡§ï‡§æ', '‡§´‡•ã‡§® ‡§ï‡•Ä ‡§≤‡§§ ‡§∞‡§ø‡§≤‡•à‡§™‡•ç‡§∏', '‡§Ö‡§§‡•ç‡§Ø‡§ß‡§ø‡§ï ‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§® ‡§ü‡§æ‡§á‡§Æ', '‡§¨‡§æ‡§ß‡•ç‡§Ø‡§ï‡§æ‡§∞‡•Ä ‡§´‡•ã‡§® ‡§ö‡•á‡§ï‡§ø‡§Ç‡§ó']
        }
      },
      internet: {
        keywords: {
          'en': ['internet addiction', 'endless browsing', 'web surfing', 'online obsession', 'can\'t stop browsing', 'internet binge'],
          'nl': ['internet verslaving', 'eindeloos browsen', 'web surfen', 'online obsessie', 'kan niet stoppen browsen', 'internet binge'],
          'de': ['internet sucht', 'endloses browsen', 'web surfen', 'online obsession', 'kann nicht aufh√∂ren browsen', 'internet binge'],
          'fr': ['addiction internet', 'navigation infinie', 'surf web', 'obsession en ligne', 'ne peux pas arr√™ter naviguer', 'binge internet'],
          'es': ['adicci√≥n internet', 'navegaci√≥n infinita', 'surf web', 'obsesi√≥n online', 'no puedo parar navegar', 'atrac√≥n internet'],
          'it': ['dipendenza internet', 'navigazione infinita', 'surf web', 'ossessione online', 'non riesco smettere navigare', 'binge internet'],
          'pt': ['v√≠cio internet', 'navega√ß√£o infinita', 'surf web', 'obsess√£o online', 'n√£o consigo parar navegar', 'compuls√£o internet'],
          'ru': ['–∏–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å', '–±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –±—Ä–∞—É–∑–∏–Ω–≥', '–≤–µ–±-—Å–µ—Ä—Ñ–∏–Ω–≥', '–æ–Ω–ª–∞–π–Ω-–æ–¥–µ—Ä–∂–∏–º–æ—Å—Ç—å', '–Ω–µ –º–æ–≥—É –ø–µ—Ä–µ—Å—Ç–∞—Ç—å –±—Ä–∞—É–∑–∏—Ç—å', '–∏–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑–∞–ø–æ–π'],
          'ja': ['„Éç„ÉÉ„Éà‰æùÂ≠òÁóá', 'ÁÑ°Èôê„Éñ„É©„Ç¶„Ç∏„É≥„Ç∞', '„Ç¶„Çß„Éñ„Çµ„Éº„Éï„Ç£„É≥', '„Ç™„É≥„É©„Ç§„É≥‰æùÂ≠ò', '„Éñ„É©„Ç¶„Ç∏„É≥„Ç∞„Çí„ÇÑ„ÇÅ„Çâ„Çå„Å™„ÅÑ', '„Éç„ÉÉ„Éà‰æùÂ≠ò'],
          'ko': ['Ïù∏ÌÑ∞ÎÑ∑ Ï§ëÎèÖ', 'Î¨¥Ìïú Î∏åÎùºÏö∞Ïßï', 'Ïõπ ÏÑúÌïë', 'Ïò®ÎùºÏù∏ Í∞ïÎ∞ï', 'Î∏åÎùºÏö∞ÏßïÏùÑ Î©àÏ∂ú Ïàò ÏóÜÎã§', 'Ïù∏ÌÑ∞ÎÑ∑ Ìè≠Ïãù'],
          'zh': ['ÁΩëÁªúÊàêÁòæ', 'Êó†ÈôêÊµèËßà', 'ÁΩë‰∏äÂÜ≤Êµ™', 'Âú®Á∫øÂº∫Ëø´Áóá', 'ÂÅú‰∏ç‰∏ãÊù•ÊµèËßà', 'ÁΩëÁªúÊö¥È£ü'],
          'ar': ['ÿ•ÿØŸÖÿßŸÜ ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™', 'ÿ™ÿµŸÅÿ≠ ŸÑÿß ŸÜŸáÿßÿ¶Ÿä', 'ÿ™ÿµŸÅÿ≠ ÿßŸÑŸàŸäÿ®', 'ŸáŸàÿ≥ ÿ£ŸàŸÜŸÑÿßŸäŸÜ', 'ŸÑÿß ÿ£ÿ≥ÿ™ÿ∑Ÿäÿπ ÿßŸÑÿ™ŸàŸÇŸÅ ÿπŸÜ ÿßŸÑÿ™ÿµŸÅÿ≠', 'ŸÜŸáŸÖ ÿ•ŸÜÿ™ÿ±ŸÜÿ™'],
          'hi': ['‡§á‡§Ç‡§ü‡§∞‡§®‡•á‡§ü ‡§ï‡•Ä ‡§≤‡§§', '‡§Ö‡§Ç‡§§‡§π‡•Ä‡§® ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§ø‡§Ç‡§ó', '‡§µ‡•á‡§¨ ‡§∏‡§∞‡•ç‡§´‡§ø‡§Ç‡§ó', '‡§ë‡§®‡§≤‡§æ‡§á‡§® ‡§ú‡•Å‡§®‡•Ç‡§®', '‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§ø‡§Ç‡§ó ‡§¨‡§Ç‡§¶ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ', '‡§á‡§Ç‡§ü‡§∞‡§®‡•á‡§ü ‡§¨‡§ø‡§Ç‡§ú']
        },
        contextPhrases: {
          'en': ['browsed for hours', 'internet addiction relapse', 'couldn\'t stop browsing', 'endless web surfing', 'online binge session'],
          'nl': ['uren gebrowst', 'internet verslaving terugval', 'kon niet stoppen browsen', 'eindeloos web surfen', 'online binge sessie'],
          'de': ['stunden gebrowst', 'internet sucht r√ºckfall', 'konnte nicht aufh√∂ren browsen', 'endloses web surfen', 'online binge session'],
          'fr': ['navigu√© heures', 'rechute addiction internet', 'n\'ai pas pu arr√™ter naviguer', 'surf web sans fin', 'session binge en ligne'],
          'es': ['navegado horas', 'reca√≠da adicci√≥n internet', 'no pude parar navegar', 'surf web infinito', 'sesi√≥n atrac√≥n online'],
          'it': ['navigato ore', 'ricaduta dipendenza internet', 'non riuscivo smettere navigare', 'surf web infinito', 'sessione binge online'],
          'pt': ['naveguei horas', 'reca√≠da v√≠cio internet', 'n√£o consegui parar navegar', 'surf web infinito', 'sess√£o compuls√£o online'],
          'ru': ['–±—Ä–∞—É–∑–∏–ª —á–∞—Å–∞–º–∏', '—Ä–µ—Ü–∏–¥–∏–≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏', '–Ω–µ –º–æ–≥ –ø–µ—Ä–µ—Å—Ç–∞—Ç—å –±—Ä–∞—É–∑–∏—Ç—å', '–±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –≤–µ–±-—Å–µ—Ä—Ñ–∏–Ω–≥', '—Å–µ–∞–Ω—Å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑–∞–ø–æ—è'],
          'ja': ['‰ΩïÊôÇÈñì„ÇÇ„Éñ„É©„Ç¶„Ç∏„É≥„Ç∞', '„Éç„ÉÉ„Éà‰æùÂ≠òÁóáÂÜçÁô∫', '„Éñ„É©„Ç¶„Ç∏„É≥„Ç∞„Çí„ÇÑ„ÇÅ„Çâ„Çå„Å™„Åã„Å£„Åü', 'ÁÑ°Èôê„Ç¶„Çß„Éñ„Çµ„Éº„Éï„Ç£„É≥', '„Ç™„É≥„É©„Ç§„É≥‰æùÂ≠ò„Çª„ÉÉ„Ç∑„Éß„É≥'],
          'ko': ['Î™á ÏãúÍ∞Ñ Î∏åÎùºÏö∞Ïßï', 'Ïù∏ÌÑ∞ÎÑ∑ Ï§ëÎèÖ Ïû¨Î∞ú', 'Î∏åÎùºÏö∞ÏßïÏùÑ Î©àÏ∂ú Ïàò ÏóÜÏóàÎã§', 'Î¨¥Ìïú Ïõπ ÏÑúÌïë', 'Ïò®ÎùºÏù∏ Ìè≠Ïãù ÏÑ∏ÏÖò'],
          'zh': ['ÊµèËßà‰∫ÜÂá†‰∏™Â∞èÊó∂', 'ÁΩëÁªúÊàêÁòæÂ§çÂèë', 'ÂÅú‰∏ç‰∏ãÊù•ÊµèËßà', 'Êó†ÈôêÁΩë‰∏äÂÜ≤Êµ™', 'Âú®Á∫øÊö¥È£ü‰ºöËØù'],
          'ar': ['ÿ™ÿµŸÅÿ≠ÿ™ ÿ≥ÿßÿπÿßÿ™', 'ÿßŸÜÿ™ŸÉÿßÿ≥ ÿ•ÿØŸÖÿßŸÜ ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™', 'ŸÑŸÖ ÿ£ÿ≥ÿ™ÿ∑ÿπ ÿßŸÑÿ™ŸàŸÇŸÅ ÿπŸÜ ÿßŸÑÿ™ÿµŸÅÿ≠', 'ÿ™ÿµŸÅÿ≠ ŸàŸäÿ® ŸÑÿß ŸÜŸáÿßÿ¶Ÿä', 'ÿ¨ŸÑÿ≥ÿ© ŸÜŸáŸÖ ÿ£ŸàŸÜŸÑÿßŸäŸÜ'],
          'hi': ['‡§ò‡§Ç‡§ü‡•ã‡§Ç ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§ø‡§Ç‡§ó', '‡§á‡§Ç‡§ü‡§∞‡§®‡•á‡§ü ‡§ï‡•Ä ‡§≤‡§§ ‡§∞‡§ø‡§≤‡•à‡§™‡•ç‡§∏', '‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§ø‡§Ç‡§ó ‡§¨‡§Ç‡§¶ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§æ', '‡§Ö‡§®‡§Ç‡§§ ‡§µ‡•á‡§¨ ‡§∏‡§∞‡•ç‡§´‡§ø‡§Ç‡§ó', '‡§ë‡§®‡§≤‡§æ‡§á‡§® ‡§¨‡§ø‡§Ç‡§ú ‡§∏‡•á‡§∂‡§®']
        }
      },
      other: {
        keywords: {
          'en': ['addiction', 'compulsive behavior', 'can\'t stop', 'addicted to', 'relapse', 'craving', 'urge', 'compulsion'],
          'nl': ['verslaving', 'dwangmatig gedrag', 'kan niet stoppen', 'verslaafd aan', 'terugval', 'trek', 'drang', 'dwang'],
          'de': ['sucht', 'zwanghaftes verhalten', 'kann nicht aufh√∂ren', 's√ºchtig nach', 'r√ºckfall', 'verlangen', 'drang', 'zwang'],
          'fr': ['addiction', 'comportement compulsif', 'ne peux pas arr√™ter', 'accro √†', 'rechute', 'envie', 'pulsion', 'compulsion'],
          'es': ['adicci√≥n', 'comportamiento compulsivo', 'no puedo parar', 'adicto a', 'reca√≠da', 'antojo', 'impulso', 'compulsi√≥n'],
          'it': ['dipendenza', 'comportamento compulsivo', 'non riesco smettere', 'dipendente da', 'ricaduta', 'voglia', 'impulso', 'compulsione'],
          'pt': ['v√≠cio', 'comportamento compulsivo', 'n√£o consigo parar', 'viciado em', 'reca√≠da', 'vontade', 'impulso', 'compuls√£o'],
          'ru': ['–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å', '–∫–æ–º–ø—É–ª—å—Å–∏–≤–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ', '–Ω–µ –º–æ–≥—É –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è', '–∑–∞–≤–∏—Å–∏–º –æ—Ç', '—Ä–µ—Ü–∏–¥–∏–≤', '—Ç—è–≥–∞', '–≤–ª–µ—á–µ–Ω–∏–µ', '–∫–æ–º–ø—É–ª—å—Å–∏—è'],
          'ja': ['‰æùÂ≠òÁóá', 'Âº∑Ëø´ÁöÑË°åÂãï', '„ÇÑ„ÇÅ„Çâ„Çå„Å™„ÅÑ', '‰æùÂ≠ò„Åó„Å¶„ÅÑ„Çã', 'ÂÜçÁô∫', 'Ê∏áÊúõ', 'Ë°ùÂãï', 'Âº∑Ëø´'],
          'ko': ['Ï§ëÎèÖ', 'Í∞ïÎ∞ïÏ†Å ÌñâÎèô', 'Î©àÏ∂ú Ïàò ÏóÜÎã§', 'Ï§ëÎèÖÎêú', 'Ïû¨Î∞ú', 'Í∞àÎßù', 'Ï∂©Îèô', 'Í∞ïÎ∞ï'],
          'zh': ['ÊàêÁòæ', 'Âº∫Ëø´Ë°å‰∏∫', 'ÂÅú‰∏ç‰∏ãÊù•', '‰∏äÁòæ‰∫Ü', 'Â§çÂèë', 'Ê∏¥Êúõ', 'ÂÜ≤Âä®', 'Âº∫Ëø´'],
          'ar': ['ÿ•ÿØŸÖÿßŸÜ', 'ÿ≥ŸÑŸàŸÉ ŸÇŸáÿ±Ÿä', 'ŸÑÿß ÿ£ÿ≥ÿ™ÿ∑Ÿäÿπ ÿßŸÑÿ™ŸàŸÇŸÅ', 'ŸÖÿØŸÖŸÜ ÿπŸÑŸâ', 'ÿßŸÜÿ™ŸÉÿßÿ≥', 'ÿ±ÿ∫ÿ®ÿ© ÿ¥ÿØŸäÿØÿ©', 'ÿØÿßŸÅÿπ', 'ÿ•ÿ¨ÿ®ÿßÿ±'],
          'hi': ['‡§≤‡§§', '‡§¨‡§æ‡§ß‡•ç‡§Ø‡§ï‡§æ‡§∞‡•Ä ‡§µ‡•ç‡§Ø‡§µ‡§π‡§æ‡§∞', '‡§∞‡•ã‡§ï ‡§®‡§π‡•Ä‡§Ç ‡§∏‡§ï‡§§‡§æ', '‡§Ü‡§¶‡•Ä', '‡§´‡§ø‡§∞ ‡§∏‡•á ‡§∂‡•Å‡§∞‡•Å‡§Ü‡§§', '‡§≤‡§æ‡§≤‡§∏‡§æ', '‡§á‡§ö‡•ç‡§õ‡§æ', '‡§¨‡§æ‡§ß‡•ç‡§Ø‡§§‡§æ']
        },
        contextPhrases: {
          'en': ['addiction relapse', 'compulsive behavior episode', 'couldn\'t control urge', 'gave in to craving', 'lost control'],
          'nl': ['verslaving terugval', 'dwangmatig gedrag episode', 'kon drang niet controleren', 'bezweken voor trek', 'controle verloren'],
          'de': ['sucht r√ºckfall', 'zwanghaftes verhalten episode', 'konnte drang nicht kontrollieren', 'dem verlangen nachgegeben', 'kontrolle verloren'],
          'fr': ['rechute addiction', '√©pisode comportement compulsif', 'n\'ai pas pu contr√¥ler pulsion', 'c√©d√© √† l\'envie', 'perdu contr√¥le'],
          'es': ['reca√≠da adicci√≥n', 'episodio comportamiento compulsivo', 'no pude controlar impulso', 'ced√≠ al antojo', 'perd√≠ control'],
          'it': ['ricaduta dipendenza', 'episodio comportamento compulsivo', 'non riuscivo controllare impulso', 'ceduto alla voglia', 'perso controllo'],
          'pt': ['reca√≠da v√≠cio', 'epis√≥dio comportamento compulsivo', 'n√£o consegui controlar impulso', 'cedi √† vontade', 'perdi controle'],
          'ru': ['—Ä–µ—Ü–∏–¥–∏–≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏', '—ç–ø–∏–∑–æ–¥ –∫–æ–º–ø—É–ª—å—Å–∏–≤–Ω–æ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è', '–Ω–µ –º–æ–≥ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä–æ–≤–∞—Ç—å –≤–ª–µ—á–µ–Ω–∏–µ', '–ø–æ–¥–¥–∞–ª—Å—è —Ç—è–≥–µ', '–ø–æ—Ç–µ—Ä—è–ª –∫–æ–Ω—Ç—Ä–æ–ª—å'],
          'ja': ['‰æùÂ≠òÁóáÂÜçÁô∫', 'Âº∑Ëø´ÁöÑË°åÂãï„Ç®„Éî„ÇΩ„Éº„Éâ', 'Ë°ùÂãï„Çí„Ç≥„É≥„Éà„É≠„Éº„É´„Åß„Åç„Å™„Åã„Å£„Åü', 'Ê∏áÊúõ„Å´Â±à„Åó„Åü', '„Ç≥„É≥„Éà„É≠„Éº„É´„ÇíÂ§±„Å£„Åü'],
          'ko': ['Ï§ëÎèÖ Ïû¨Î∞ú', 'Í∞ïÎ∞ïÏ†Å ÌñâÎèô ÏóêÌîºÏÜåÎìú', 'Ï∂©ÎèôÏùÑ ÌÜµÏ†úÌï† Ïàò ÏóÜÏóàÎã§', 'Í∞àÎßùÏóê Íµ¥Î≥µÌñàÎã§', 'ÌÜµÏ†úÎ†•ÏùÑ ÏûÉÏóàÎã§'],
          'zh': ['ÊàêÁòæÂ§çÂèë', 'Âº∫Ëø´Ë°å‰∏∫Âèë‰Ωú', 'Êó†Ê≥ïÊéßÂà∂ÂÜ≤Âä®', 'Â±àÊúç‰∫éÊ∏¥Êúõ', 'Â§±ÂéªÊéßÂà∂'],
          'ar': ['ÿßŸÜÿ™ŸÉÿßÿ≥ ÿßŸÑÿ•ÿØŸÖÿßŸÜ', 'ŸÜŸàÿ®ÿ© ÿ≥ŸÑŸàŸÉ ŸÇŸáÿ±Ÿä', 'ŸÑŸÖ ÿ£ÿ≥ÿ™ÿ∑ÿπ ÿßŸÑÿ≥Ÿäÿ∑ÿ±ÿ© ÿπŸÑŸâ ÿßŸÑÿØÿßŸÅÿπ', 'ÿßÿ≥ÿ™ÿ≥ŸÑŸÖÿ™ ŸÑŸÑÿ±ÿ∫ÿ®ÿ©', 'ŸÅŸÇÿØÿ™ ÿßŸÑÿ≥Ÿäÿ∑ÿ±ÿ©'],
          'hi': ['‡§≤‡§§ ‡§ï‡§æ ‡§∞‡§ø‡§≤‡•à‡§™‡•ç‡§∏', '‡§¨‡§æ‡§ß‡•ç‡§Ø‡§ï‡§æ‡§∞‡•Ä ‡§µ‡•ç‡§Ø‡§µ‡§π‡§æ‡§∞ ‡§è‡§™‡§ø‡§∏‡•ã‡§°', '‡§á‡§ö‡•ç‡§õ‡§æ ‡§ï‡•ã ‡§®‡§ø‡§Ø‡§Ç‡§§‡•ç‡§∞‡§ø‡§§ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§æ', '‡§≤‡§æ‡§≤‡§∏‡§æ ‡§ï‡•á ‡§Ü‡§ó‡•á ‡§π‡§æ‡§∞ ‡§ó‡§Ø‡§æ', '‡§®‡§ø‡§Ø‡§Ç‡§§‡•ç‡§∞‡§£ ‡§ñ‡•ã ‡§¶‡§ø‡§Ø‡§æ']
        }
      }
    };
    
    // Check each addiction type
    for (const addiction of addictions) {
      const keywordSet = addictionKeywords[addiction.type];
      if (!keywordSet) continue;
      
      // Get user's preferred language for better keyword matching
      const User = require('../models/User');
      const user = await User.findById(journalEntry.userId);
      const preferredLanguage = user?.preferredLanguage || 'en';
      
      // Check keywords for user's preferred language first, then fallback to all languages
      const languageKeywords = keywordSet.keywords[preferredLanguage] || [];
      const languagePhrases = keywordSet.contextPhrases[preferredLanguage] || [];
      
      // Check for direct keywords in user's language
      let foundKeywords = languageKeywords.filter(keyword => content.includes(keyword));
      
      // Check for context phrases in user's language (stronger indicators)
      let foundPhrases = languagePhrases.filter(phrase => content.includes(phrase));
      
      // If nothing found in preferred language, check all languages
      if (foundKeywords.length === 0 && foundPhrases.length === 0) {
        for (const [lang, keywords] of Object.entries(keywordSet.keywords)) {
          if (lang !== preferredLanguage) {
            const langKeywords = keywords.filter(keyword => content.includes(keyword));
            foundKeywords = foundKeywords.concat(langKeywords);
          }
        }
        
        for (const [lang, phrases] of Object.entries(keywordSet.contextPhrases)) {
          if (lang !== preferredLanguage) {
            const langPhrases = phrases.filter(phrase => content.includes(phrase));
            foundPhrases = foundPhrases.concat(langPhrases);
          }
        }
      }
      
      if (foundKeywords.length > 0 || foundPhrases.length > 0) {
        const trigger = foundPhrases[0] || foundKeywords[0];
        const confidence = foundPhrases.length > 0 ? 0.8 : 0.7; // Higher confidence for phrases
        
        relapseIndicators.push({
          trigger: `Keyword detection: ${trigger}`,
          confidence: confidence,
          context: `Found in journal: "${content.substring(0, 200)}..."`,
          isActualRelapse: true,
          relatedAddiction: addiction.type,
          detectionMethod: 'keyword-based'
        });
        
        console.log(`üîç Keyword match for ${addiction.type}: "${trigger}" (confidence: ${confidence})`);
      }
    }
    
    return relapseIndicators;
  } catch (error) {
    console.error('Error in keyword-based detection:', error);
    return [];
  }
};

// Handle automatic relapse detection and update addiction status
const handleAutomaticRelapseDetection = async (userId, relapseIndicators, journalEntry) => {
  try {
    const Addiction = require('../models/Addiction');
    
    for (const indicator of relapseIndicators) {
      if (indicator.relatedAddiction) {
        console.log(`üîÑ Updating addiction status for ${indicator.relatedAddiction} - detected relapse`);
        
        // Find the user's addiction of this type (include clean status as it can relapse)
        const addiction = await Addiction.findOne({ 
          userId: userId, 
          type: indicator.relatedAddiction,
          status: { $in: ['recovering', 'active', 'clean'] }
        });
        
        if (addiction) {
          // Use the new method to record automatic relapse with journal entry date
          await addiction.recordAutomaticRelapse(indicator.trigger, journalEntry._id, journalEntry.date);
          
          console.log(`‚úÖ Addiction ${indicator.relatedAddiction} status updated to relapsed via automatic detection (date: ${journalEntry.date?.toLocaleDateString('nl-NL') || 'today'})`);
          
          // TODO: Optionally send notification or trigger intervention
        } else {
          console.log(`‚ö†Ô∏è  No active addiction found for type ${indicator.relatedAddiction}`);
        }
      }
    }
  } catch (error) {
    console.error('Error handling automatic relapse detection:', error);
  }
};

// Set up multer for file uploads
// Helper function to format transcribed text with proper line breaks
const formatTranscribedText = (text, language = 'nl') => {
  if (!text || typeof text !== 'string') return text;
  
  // Multilingual abbreviations that should NOT be split
  const abbreviationsByLanguage = {
    // Dutch
    'nl': ['bijv', 'etc', 'o.a', 'd.w.z', 'm.b.v', 'b.v', 'n.v', 'v.s', 'p.s', 
           'nr', 'tel', 'fax', 'e.d', 'a.u.b', 'z.o.z', 'v.v', 'o.v.v',
           'dr', 'drs', 'prof', 'ir', 'ing', 'mr', 'mw', 'dhr', 'mevr'],
    
    // English
    'en': ['etc', 'e.g', 'i.e', 'vs', 'p.s', 'a.m', 'p.m', 'st', 'nd', 'rd', 'th',
           'dr', 'prof', 'mr', 'mrs', 'ms', 'jr', 'sr', 'co', 'inc', 'ltd',
           'no', 'vol', 'pp', 'ch', 'fig', 'ref'],
    
    // German  
    'de': ['z.b', 'etc', 'd.h', 'u.a', 'bzw', 'ggf', 'evtl', 'ca', 'max', 'min',
           'dr', 'prof', 'hr', 'fr', 'gmbh', 'ag', 'kg', 'tel', 'fax',
           'nr', 'str', 'plz', 'brd', 'ddr', 'usa', 'eu'],
    
    // French
    'fr': ['etc', 'p.ex', 'c.√†.d', 'cf', 'p.s', 'n.b', 'vs', 'av', 'apr',
           'dr', 'prof', 'm', 'mme', 'mlle', 'st', 'ste', 'cie', 's.a', 'sarl',
           'tel', 'fax', 'no', 'vol', 'ch', 'fig', 'ref'],
    
    // Spanish
    'es': ['etc', 'p.ej', 'es.decir', 'cf', 'p.d', 'vs', 'sr', 'sra', 'srta',
           'dr', 'prof', 'ing', 'lic', 'arq', 's.a', 's.l', 'tel', 'fax',
           'no', 'vol', 'cap', 'fig', 'ref', 'p√°g', 'ej'],
    
    // Italian  
    'it': ['etc', 'ad.es', 'cio√®', 'cf', 'p.s', 'vs', 'sig', 'sig.ra', 'sig.na',
           'dr', 'prof', 'ing', 'arch', 'avv', 's.p.a', 's.r.l', 'tel', 'fax',
           'no', 'vol', 'cap', 'fig', 'rif', 'pag'],
    
    // Portuguese
    'pt': ['etc', 'p.ex', 'ou.seja', 'cf', 'p.s', 'vs', 'sr', 'sra', 'srta',
           'dr', 'prof', 'eng', 'arq', 'adv', 's.a', 'ltda', 'tel', 'fax',
           'no', 'vol', 'cap', 'fig', 'ref', 'p√°g'],
    
    // Russian (using Latin transliteration for speech recognition)
    'ru': ['etc', 'i.t.d', 'i.t.p', 'vs', 'dr', 'prof', 'g', 'tel', 'fax',
           'no', 'str', 'dom', 'kv', 'ooo', 'zao', 'oao'],
    
    // Chinese (using pinyin for speech recognition)
    'zh': ['etc', 'deng.deng', 'ji.qi', 'vs', 'dr', 'prof', 'xian.sheng', 'nu.shi',
           'tel', 'fax', 'no', 'ye', 'zhang'],
    
    // Japanese (using romaji for speech recognition)
    'ja': ['etc', 'nado', 'mata.wa', 'vs', 'dr', 'prof', 'san', 'kun', 'chan',
           'tel', 'fax', 'no', 'kai.sha', 'yu.gen'],
    
    // Korean (using romanization for speech recognition)
    'ko': ['etc', 'deung.deung', 'ttoneun', 'vs', 'dr', 'prof', 'ssi', 'nim',
           'tel', 'fax', 'no', 'hoe.sa', 'yu.han'],
    
    // Arabic (using transliteration for speech recognition)
    'ar': ['etc', 'wa.ghair.ha', 'ay', 'vs', 'dr', 'prof', 'ustaz', 'sayyid',
           'tel', 'fax', 'no', 'shar.ka', 'mu.as.sa.sa'],
    
    // Hindi (using transliteration for speech recognition)
    'hi': ['etc', 'aadi', 'ya', 'vs', 'dr', 'prof', 'ji', 'sahib', 'madam',
           'tel', 'fax', 'no', 'ltd', 'pvt']
  };
  
  // Get abbreviations for the specified language (fallback to Dutch)
  const abbreviations = abbreviationsByLanguage[language] || abbreviationsByLanguage['nl'];
  
  let formatted = text;
  
  // Simple approach: replace '. ' with '.\n' but avoid abbreviations
  // First, protect abbreviations by temporarily replacing them
  const protectedAbbrevs = [];
  abbreviations.forEach((abbr, index) => {
    const placeholder = `__ABBREV_${index}__`;
    const regex = new RegExp(`\\b${abbr.replace(/\./g, '\\.')}\\. `, 'gi');
    formatted = formatted.replace(regex, (match) => {
      protectedAbbrevs.push({placeholder, original: match});
      return placeholder;
    });
  });
  
  // Now replace '. ' with '.\n'
  formatted = formatted.replace(/\.\s+/g, '.\n');
  
  // Restore protected abbreviations
  protectedAbbrevs.forEach(({placeholder, original}) => {
    formatted = formatted.replace(placeholder, original);
  });
  
  // Handle time notations and numbers (restore incorrectly split decimals)
  formatted = formatted.replace(/(\d+)\.\n(\d+)/g, '$1.$2');
  
  // Clean up whitespace but preserve newlines
  formatted = formatted.replace(/[ \t]+/g, ' ').trim();
  formatted = formatted.replace(/\n\s+/g, '\n').replace(/\s+\n/g, '\n');
  formatted = formatted.replace(/\n{3,}/g, '\n\n');
  
  return formatted;
};

const upload = multer({
  dest: path.join(__dirname, '../../temp/'),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit (Google Speech-to-Text sync max)
  },
  fileFilter: (req, file, cb) => {
    // Accept audio files supported by Google Speech-to-Text
    const allowedMimes = [
      'audio/webm',
      'audio/mp4',
      'audio/mpeg',
      'audio/wav',
      'audio/ogg',
      'audio/x-m4a',
      'audio/mp3',
      'audio/flac'
    ];
    
    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      console.log('Rejected file type:', file.mimetype);
      cb(new Error('Invalid audio format. Supported formats: WebM, MP4, WAV, MP3, OGG, FLAC'), false);
    }
  }
});

// Get today's journal entry for user
router.get('/user/today', auth, async (req, res) => {
  try {
    const userId = req.user._id;
    
    console.log('Fetching today\'s journal entry for user:', userId);
    
    const today = new Date();
    const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);
    
    const todayEntry = await JournalEntry.findOne({
      userId,
      date: {
        $gte: startOfDay,
        $lt: endOfDay
      }
    }).populate('userId', 'username');
    
    console.log('Today\'s entry found:', !!todayEntry);
    
    res.json({
      success: true,
      entry: todayEntry,
      hasEntry: !!todayEntry
    });
  } catch (error) {
    console.error('Error fetching today\'s journal entry:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch today\'s journal entry' });
  }
});

// Get user's journal entries
router.get('/user/entries', auth, async (req, res) => {
  try {
    const userId = req.user._id;
    const { page = 1, limit = 20, mood, tags, startDate, endDate, searchText } = req.query;
    
    console.log('Fetching journal entries for user:', userId);
    
    // Build filter query
    let filter = { userId };
    
    if (mood && mood !== 'all') {
      filter.mood = mood;
    }
    
    if (tags) {
      const tagArray = tags.split(',').map(tag => tag.trim());
      filter.tags = { $in: tagArray };
    }
    
    if (searchText && searchText.trim()) {
      // Add text search
      filter.$text = { $search: searchText.trim() };
    }
    
    if (startDate || endDate) {
      filter.date = {};
      if (startDate) filter.date.$gte = new Date(startDate);
      if (endDate) filter.date.$lte = new Date(endDate);
    }
    
    console.log('Filter:', filter);
    
    // Build query
    let query = JournalEntry.find(filter);
    
    // If text search is used, include text score for relevance
    if (searchText && searchText.trim()) {
      query = query.select({ score: { $meta: 'textScore' } });
      // Sort by text relevance score first, then by date
      query = query.sort({ score: { $meta: 'textScore' }, date: -1, createdAt: -1 });
    } else {
      // Regular sort by date
      query = query.sort({ date: -1, createdAt: -1 });
    }
    
    const entries = await query
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .populate('userId', 'username');
    
    const total = await JournalEntry.countDocuments(filter);
    
    console.log('Found entries:', entries.length);
    
    res.json({
      success: true,
      entries,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Error fetching journal entries:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch journal entries' });
  }
});

// Create new journal entry or update existing daily entry
router.post('/create', auth, async (req, res) => {
  try {
    const { title, content, mood, tags, date } = req.body;
    const userId = req.user._id;
    
    if (!title || !content) {
      return res.status(400).json({ 
        success: false, 
        error: 'Title and content are required' 
      });
    }
    
    // Check for nonsense text before processing
    try {
      console.log('üîç Checking content for nonsense text:', content.substring(0, 50) + '...');
      const aiService = require('../services/aiCoachService');
      const nonsenseCheck = await aiService.checkNonsenseOnly(content);
      if (nonsenseCheck.isNonsense) {
        console.log('‚ùå Nonsense text detected, rejecting journal entry:', nonsenseCheck.reason);
        return res.status(400).json({
          success: false,
          error: 'De tekst bevat onzin of betekenisloze inhoud en kan niet worden opgeslagen.',
          isNonsense: true,
          reason: nonsenseCheck.reason
        });
      }
      console.log('‚úÖ Content passed nonsense check');
    } catch (error) {
      console.error('Error checking for nonsense text:', error);
      // Continue without blocking if nonsense check fails
    }
    
    const entryDate = date ? new Date(date) : new Date();
    // Normalize to start of day for consistent comparison
    const normalizedDate = new Date(entryDate.getFullYear(), entryDate.getMonth(), entryDate.getDate());
    
    console.log('Creating/updating journal entry for date:', normalizedDate);
    
    // Analyze mood from content using AI
    const aiCoachService = require('../services/aiCoachService');
    let detectedMood = null;
    
    try {
      console.log('Analyzing mood from journal content...');
      detectedMood = await aiCoachService.analyzeMoodFromText(content, userId);
      console.log('Detected mood:', detectedMood);
    } catch (error) {
      console.error('Error analyzing mood:', error);
      // Continue without mood analysis if it fails
    }
    
    // Check if entry already exists for this date
    const existingEntry = await JournalEntry.findOne({
      userId,
      date: {
        $gte: normalizedDate,
        $lt: new Date(normalizedDate.getTime() + 24 * 60 * 60 * 1000)
      }
    });
    
    if (existingEntry) {
      console.log('Found existing entry for date, updating it');
      
      // Check for nonsense text before appending to existing entry
      try {
        console.log('üîç Checking new content for nonsense text before appending:', content.substring(0, 50) + '...');
        const aiService = require('../services/aiCoachService');
        const nonsenseCheck = await aiService.checkNonsenseOnly(content);
        if (nonsenseCheck.isNonsense) {
          console.log('‚ùå Nonsense text detected in append, rejecting:', nonsenseCheck.reason);
          return res.status(400).json({
            success: false,
            error: 'De tekst bevat onzin of betekenisloze inhoud en kan niet worden opgeslagen.',
            isNonsense: true,
            reason: nonsenseCheck.reason
          });
        }
        console.log('‚úÖ Content passed nonsense check for append');
      } catch (error) {
        console.error('Error checking for nonsense text in append:', error);
        // Continue without blocking if nonsense check fails
      }
      
      // Update existing entry - append content
      existingEntry.content = existingEntry.content + '\n\n' + content.trim();
      
      // Use AI-detected mood or fallback to user-provided mood
      if (detectedMood && detectedMood.primaryMood) {
        existingEntry.mood = detectedMood.primaryMood;
        existingEntry.moodScore = detectedMood.moodScore;
        existingEntry.moodAnalysis = {
          aiGenerated: true,
          confidence: detectedMood.confidence,
          emotionalIndicators: detectedMood.emotionalIndicators,
          overallSentiment: detectedMood.overallSentiment,
          description: detectedMood.moodDescription,
          detectedMoods: detectedMood.detectedMoods || [],
          moodCount: detectedMood.moodCount || 1,
          emotionalIntensity: detectedMood.emotionalIntensity || 3,
          emotionalTransition: detectedMood.emotionalTransition || 'stable',
          suggestedFocus: detectedMood.suggestedFocus || null
        };
      } else if (mood && typeof mood === 'string' && mood.trim()) {
        existingEntry.mood = mood.trim();
        existingEntry.moodAnalysis = { aiGenerated: false };
      }
      
      // Merge tags if provided
      if (tags && Array.isArray(tags) && tags.length > 0) {
        const newTags = tags.map(tag => tag.trim()).filter(tag => tag.length > 0);
        const existingTags = existingEntry.tags || [];
        // Combine and deduplicate tags
        existingEntry.tags = [...new Set([...existingTags, ...newTags])];
      }
      
      await existingEntry.save();
      await existingEntry.populate('userId', 'username');
      
      // Trigger AI Coach analysis for updated entry
      triggerAICoachAnalysis(existingEntry);
      
      res.json({
        success: true,
        entry: existingEntry,
        message: 'Journal entry updated successfully',
        wasUpdated: true,
        detectedMood: detectedMood
      });
    } else {
      // Create new entry
      const entryData = {
        userId,
        title: title.trim(),
        content: content.trim(),
        date: normalizedDate
      };

      // Use AI-detected mood or fallback to user-provided mood
      if (detectedMood && detectedMood.primaryMood) {
        entryData.mood = detectedMood.primaryMood;
        entryData.moodScore = detectedMood.moodScore;
        entryData.moodAnalysis = {
          aiGenerated: true,
          confidence: detectedMood.confidence,
          emotionalIndicators: detectedMood.emotionalIndicators,
          overallSentiment: detectedMood.overallSentiment,
          description: detectedMood.moodDescription,
          detectedMoods: detectedMood.detectedMoods || [],
          moodCount: detectedMood.moodCount || 1,
          emotionalIntensity: detectedMood.emotionalIntensity || 3,
          emotionalTransition: detectedMood.emotionalTransition || 'stable',
          suggestedFocus: detectedMood.suggestedFocus || null
        };
      } else if (mood && typeof mood === 'string' && mood.trim()) {
        entryData.mood = mood.trim();
        entryData.moodAnalysis = { aiGenerated: false };
      }

      // Only add tags if they exist
      if (tags && Array.isArray(tags) && tags.length > 0) {
        entryData.tags = tags.map(tag => tag.trim()).filter(tag => tag.length > 0);
      }

      const newEntry = new JournalEntry(entryData);
      
      await newEntry.save();
      await newEntry.populate('userId', 'username');
      
      // Trigger AI Coach analysis for new entry
      triggerAICoachAnalysis(newEntry);
      
      res.json({
        success: true,
        entry: newEntry,
        message: 'Journal entry created successfully',
        wasUpdated: false,
        detectedMood: detectedMood
      });
    }
  } catch (error) {
    console.error('Error creating/updating journal entry:', error);
    res.status(500).json({ success: false, error: 'Failed to create journal entry' });
  }
});

// Update journal entry
router.put('/:entryId', auth, async (req, res) => {
  try {
    const { entryId } = req.params;
    const { title, content, mood, tags } = req.body;
    const userId = req.user._id;
    
    console.log('Updating journal entry:', {
      entryId,
      userId,
      title,
      content: content?.substring(0, 50) + '...',
      mood,
      tags
    });
    
    const entry = await JournalEntry.findById(entryId);
    if (!entry) {
      console.log('Entry not found:', entryId);
      return res.status(404).json({ success: false, error: 'Journal entry not found' });
    }
    
    // Check if user owns this entry
    if (entry.userId.toString() !== userId) {
      console.log('Unauthorized update attempt:', {
        entryUserId: entry.userId.toString(),
        requestUserId: userId
      });
      return res.status(403).json({ success: false, error: 'Not authorized to update this entry' });
    }
    
    console.log('Before update:', {
      title: entry.title,
      content: entry.content.substring(0, 50) + '...',
      mood: entry.mood,
      tags: entry.tags
    });
    
    // Check for nonsense text before updating content
    if (content !== undefined) {
      try {
        console.log('üîç Checking updated content for nonsense text:', content.substring(0, 50) + '...');
        const aiCoachService = require('../services/aiCoachService');
        const nonsenseCheck = await aiCoachService.checkNonsenseOnly(content);
        console.log('üîç Nonsense check result for update:', nonsenseCheck);
        if (nonsenseCheck.isNonsense) {
          console.log('‚ùå Nonsense text detected in update, rejecting:', nonsenseCheck.reason);
          return res.status(400).json({
            success: false,
            error: 'De tekst bevat onzin of betekenisloze inhoud en kan niet worden opgeslagen.',
            isNonsense: true,
            reason: nonsenseCheck.reason
          });
        }
        console.log('‚úÖ Updated content passed nonsense check');
      } catch (error) {
        console.error('‚ùå Error checking updated content for nonsense text:', error);
        // Don't continue silently - this might be why updates aren't being blocked
        console.log('‚ö†Ô∏è Nonsense check failed, but continuing with update due to error');
      }
    }

    // Update fields
    if (title !== undefined) entry.title = title.trim();
    if (content !== undefined) {
      entry.content = content.trim();
      
      // Re-analyze mood when content changes
      try {
        console.log('Re-analyzing mood after content update...');
        const aiCoachService = require('../services/aiCoachService');
        const detectedMood = await aiCoachService.analyzeMoodFromText(entry.content, userId);
        
        if (detectedMood && detectedMood.primaryMood) {
          entry.mood = detectedMood.primaryMood;
          entry.moodScore = detectedMood.moodScore;
          entry.moodAnalysis = {
            aiGenerated: true,
            confidence: detectedMood.confidence,
            emotionalIndicators: detectedMood.emotionalIndicators,
            overallSentiment: detectedMood.overallSentiment,
            description: detectedMood.moodDescription,
            detectedMoods: detectedMood.detectedMoods || [],
            moodCount: detectedMood.moodCount || 1
          };
          console.log('Updated mood after content change:', detectedMood.primaryMood);
        }
      } catch (error) {
        console.error('Error re-analyzing mood:', error);
      }
    }
    
    // Handle manual mood override if provided
    if (mood !== undefined) {
      if (mood && typeof mood === 'string' && mood.trim()) {
        entry.mood = mood.trim();
        entry.moodAnalysis = { aiGenerated: false }; // Mark as manually set
      } else {
        entry.mood = undefined; // Remove mood if empty/null
        entry.moodAnalysis = undefined;
      }
    }
    
    // Handle tags update
    if (tags !== undefined) {
      if (Array.isArray(tags) && tags.length > 0) {
        entry.tags = tags.map(tag => tag.trim()).filter(tag => tag.length > 0);
      } else {
        entry.tags = []; // Empty array if no tags
      }
    }
    
    await entry.save();
    await entry.populate('userId', 'username');
    
    console.log('After update:', {
      title: entry.title,
      content: entry.content.substring(0, 50) + '...',
      mood: entry.mood,
      tags: entry.tags
    });
    
    res.json({
      success: true,
      entry,
      message: 'Journal entry updated successfully'
    });
  } catch (error) {
    console.error('Error updating journal entry:', error);
    res.status(500).json({ success: false, error: 'Failed to update journal entry' });
  }
});

// Delete journal entry
router.delete('/:entryId', auth, async (req, res) => {
  try {
    const { entryId } = req.params;
    const userId = req.user._id;
    
    const entry = await JournalEntry.findById(entryId);
    if (!entry) {
      return res.status(404).json({ success: false, error: 'Journal entry not found' });
    }
    
    // Check if user owns this entry
    if (entry.userId.toString() !== userId) {
      return res.status(403).json({ success: false, error: 'Not authorized to delete this entry' });
    }
    
    // Delete audio file if it exists
    if (entry.audioFile && entry.audioFile.filename) {
      const audioPath = path.join(journalsDir, entry.audioFile.filename);
      if (fs.existsSync(audioPath)) {
        fs.unlinkSync(audioPath);
      }
    }
    
    await JournalEntry.findByIdAndDelete(entryId);
    
    res.json({
      success: true,
      message: 'Journal entry deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting journal entry:', error);
    res.status(500).json({ success: false, error: 'Failed to delete journal entry' });
  }
});

// Generate audio for journal entry using Eleven Labs
router.post('/:entryId/generate-audio', auth, async (req, res) => {
  try {
    const { entryId } = req.params;
    const { voiceId = 'EXAVITQu4vr4xnSDxMaL' } = req.body;
    const userId = req.user._id;
    
    console.log('Generate audio request received:', { entryId, userId, voiceId });
    
    // Check user credits
    const user = await User.findById(userId);
    console.log('User found:', user ? `${user.username} with ${user.credits} credits` : 'null');
    if (!user || user.credits < 1) {
      return res.status(400).json({ 
        success: false, 
        error: 'Insufficient credits. You need 1 credit to generate audio.' 
      });
    }
    
    const entry = await JournalEntry.findById(entryId);
    if (!entry) {
      return res.status(404).json({ success: false, error: 'Journal entry not found' });
    }
    
    // Check if user owns this entry
    if (entry.userId.toString() !== userId) {
      return res.status(403).json({ success: false, error: 'Not authorized to generate audio for this entry' });
    }
    
    // Create journal entry text for TTS
    const journalText = `${entry.title}. ${entry.content}`;
    
    // Generate unique filename
    const timestamp = Date.now();
    const filename = `journal_${timestamp}_${entryId.slice(-8)}.mp3`;
    const outputPath = path.join(journalsDir, filename);
    
    try {
      // Call Eleven Labs API
      const elevenLabsResponse = await axios.post(
        `https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`,
        {
          text: journalText,
          model_id: "eleven_multilingual_v2",
          voice_settings: {
            stability: 0.65,
            similarity_boost: 0.2,
            style: 0.2,
            use_speaker_boost: true
          }
        },
        {
          headers: {
            'Accept': 'audio/mpeg',
            'Content-Type': 'application/json',
            'xi-api-key': process.env.ELEVEN_LABS_API_KEY
          },
          responseType: 'stream'
        }
      );

      // Save the audio file
      const writeStream = fs.createWriteStream(outputPath);
      elevenLabsResponse.data.pipe(writeStream);
      
      await new Promise((resolve, reject) => {
        writeStream.on('finish', resolve);
        writeStream.on('error', reject);
      });
      
      // Get audio duration (approximate based on text length)
      const estimatedDuration = Math.max(30, Math.floor(journalText.length / 10));
      
      // Update journal entry with audio info
      entry.audioFile = {
        filename,
        duration: estimatedDuration,
        language: 'nl',
        voiceId
      };
      await entry.save();
      
      // Deduct credit from user
      await user.spendCredits(1, 'generation', `Journal voice generation for "${entry.title}"`, entryId);
      
      res.json({
        success: true,
        entry,
        audioFile: entry.audioFile,
        message: 'Journal audio generated successfully'
      });
    } catch (ttsError) {
      console.error('Eleven Labs TTS generation error:', ttsError);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to generate audio. Please check your Eleven Labs API key and try again.' 
      });
    }
  } catch (error) {
    console.error('Error generating journal audio:', error);
    res.status(500).json({ success: false, error: 'Failed to generate journal audio' });
  }
});

// Share journal entry publicly
router.post('/:entryId/share', auth, async (req, res) => {
  try {
    const { entryId } = req.params;
    const userId = req.user._id;
    
    const entry = await JournalEntry.findById(entryId);
    if (!entry) {
      return res.status(404).json({ success: false, error: 'Journal entry not found' });
    }
    
    // Check if user owns this entry
    if (entry.userId.toString() !== userId) {
      return res.status(403).json({ success: false, error: 'Not authorized to share this entry' });
    }
    
    // Update sharing status
    entry.isShared = true;
    entry.privacy = 'public';
    entry.sharedAt = new Date();
    
    await entry.save();
    await entry.populate('userId', 'username');
    
    res.json({
      success: true,
      entry,
      message: 'Journal entry shared successfully'
    });
  } catch (error) {
    console.error('Error sharing journal entry:', error);
    res.status(500).json({ success: false, error: 'Failed to share journal entry' });
  }
});

// Get shared journal entries (community)
router.get('/shared', async (req, res) => {
  try {
    const { page = 1, limit = 20, mood, tags, language } = req.query;
    
    // Build filter for shared entries
    let filter = { isShared: true, privacy: 'public' };
    
    if (mood && mood !== 'all') {
      filter.mood = mood;
    }
    
    if (tags) {
      const tagArray = tags.split(',').map(tag => tag.trim());
      filter.tags = { $in: tagArray };
    }
    
    if (language && language !== 'all') {
      filter['audioFile.language'] = language;
    }
    
    const entries = await JournalEntry.find(filter)
      .sort({ sharedAt: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .populate('userId', 'username')
      .select('-content'); // Don't expose full content in shared view initially
    
    const total = await JournalEntry.countDocuments(filter);
    
    res.json({
      success: true,
      entries,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Error fetching shared journal entries:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch shared journal entries' });
  }
});

// Get full shared journal entry (for reading)
router.get('/shared/:entryId', async (req, res) => {
  try {
    const { entryId } = req.params;
    
    const entry = await JournalEntry.findById(entryId)
      .populate('userId', 'username');
    
    if (!entry || !entry.isShared || entry.privacy !== 'public') {
      return res.status(404).json({ success: false, error: 'Shared journal entry not found' });
    }
    
    res.json({
      success: true,
      entry
    });
  } catch (error) {
    console.error('Error fetching shared journal entry:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch shared journal entry' });
  }
});

// Like/unlike journal entry
router.post('/:entryId/like', auth, async (req, res) => {
  try {
    const { entryId } = req.params;
    const userId = req.user._id;
    
    const entry = await JournalEntry.findById(entryId);
    if (!entry || !entry.isShared) {
      return res.status(404).json({ success: false, error: 'Shared journal entry not found' });
    }
    
    const result = await entry.toggleLike(userId);
    
    res.json({
      success: true,
      isLiked: result.isLiked,
      likeCount: result.likeCount
    });
  } catch (error) {
    console.error('Error liking journal entry:', error);
    res.status(500).json({ success: false, error: 'Failed to like journal entry' });
  }
});

// Get journal statistics for user
router.get('/stats', auth, async (req, res) => {
  try {
    const userId = req.user._id;
    
    const totalEntries = await JournalEntry.countDocuments({ userId });
    const sharedEntries = await JournalEntry.countDocuments({ userId, isShared: true });
    const entriesWithAudio = await JournalEntry.countDocuments({ 
      userId, 
      'audioFile.filename': { $exists: true } 
    });
    
    // Get mood distribution
    const moodStats = await JournalEntry.aggregate([
      { $match: { userId: new require('mongoose').Types.ObjectId(userId) } },
      { $group: { _id: '$mood', count: { $sum: 1 } } },
      { $sort: { count: -1 } }
    ]);
    
    // Get recent activity (last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    const recentEntries = await JournalEntry.countDocuments({
      userId,
      createdAt: { $gte: thirtyDaysAgo }
    });
    
    res.json({
      success: true,
      stats: {
        totalEntries,
        sharedEntries,
        entriesWithAudio,
        recentEntries,
        moodStats
      }
    });
  } catch (error) {
    console.error('Error fetching journal stats:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch journal statistics' });
  }
});

// Transcribe audio to text using Google Speech-to-Text
router.post('/transcribe', auth, upload.single('audio'), async (req, res) => {
  try {
    const { language = 'nl-NL' } = req.body;
    
    if (!req.file) {
      return res.status(400).json({ success: false, error: 'No audio file provided' });
    }

    console.log('Transcribing audio file with Google Speech-to-Text:', req.file.path);
    console.log('File details:', {
      size: req.file.size,
      mimetype: req.file.mimetype,
      originalname: req.file.originalname
    });

    // Check file size (max 10MB for Google Speech-to-Text sync)
    if (req.file.size > 10 * 1024 * 1024) {
      fs.unlinkSync(req.file.path);
      return res.status(400).json({ success: false, error: 'Audio file too large. Maximum size is 10MB.' });
    }

    // Check if file exists and has content
    if (!fs.existsSync(req.file.path) || fs.statSync(req.file.path).size === 0) {
      if (fs.existsSync(req.file.path)) {
        fs.unlinkSync(req.file.path);
      }
      return res.status(400).json({ success: false, error: 'Invalid or empty audio file' });
    }

    // Initialize Google Speech client
    const speech = require('@google-cloud/speech');
    let client;
    
    // Use API key if available, otherwise use default credentials
    if (process.env.GOOGLE_CLOUD_API_KEY) {
      client = new speech.SpeechClient({
        apiKey: process.env.GOOGLE_CLOUD_API_KEY
      });
    } else {
      client = new speech.SpeechClient();
    }

    // Read the audio file
    const audioBytes = fs.readFileSync(req.file.path).toString('base64');

    // Configure the request
    const request = {
      audio: {
        content: audioBytes,
      },
      config: {
        encoding: 'WEBM_OPUS', // Default for WebM files
        sampleRateHertz: 48000,
        languageCode: language,
        enableAutomaticPunctuation: true,
        model: 'latest_long', // Better for longer audio
      },
    };

    // Handle different audio formats
    if (req.file.mimetype) {
      if (req.file.mimetype.includes('wav')) {
        request.config.encoding = 'LINEAR16';
        request.config.sampleRateHertz = 44100;
      } else if (req.file.mimetype.includes('mp3') || req.file.mimetype.includes('mpeg')) {
        request.config.encoding = 'MP3';
      } else if (req.file.mimetype.includes('mp4')) {
        request.config.encoding = 'MP3';
      } else if (req.file.mimetype.includes('ogg')) {
        request.config.encoding = 'OGG_OPUS';
      }
    }

    console.log('Calling Google Speech-to-Text API with config:', {
      encoding: request.config.encoding,
      sampleRateHertz: request.config.sampleRateHertz,
      languageCode: request.config.languageCode
    });

    // Perform the speech recognition request
    const [response] = await client.recognize(request);
    
    // Clean up temporary file
    fs.unlinkSync(req.file.path);

    console.log('Google Speech-to-Text response received:', {
      hasResults: !!response.results && response.results.length > 0
    });

    if (response.results && response.results.length > 0) {
      // Combine all transcriptions
      let transcription = '';
      response.results.forEach(result => {
        if (result.alternatives && result.alternatives[0]) {
          transcription += result.alternatives[0].transcript + ' ';
        }
      });

      transcription = transcription.trim();
      
      if (transcription) {
        // Convert Google Speech language code to UI language code
        const uiLanguage = language.split('-')[0]; // e.g., 'nl-NL' -> 'nl', 'en-US' -> 'en'
        
        // Apply text formatting to add line breaks after sentences
        const formattedTranscription = formatTranscribedText(transcription, uiLanguage);
        
        // Log language used for debugging (can be removed in production)
        console.log('Speech-to-text formatted for language:', uiLanguage);
        
        res.json({
          success: true,
          transcription: formattedTranscription
        });
      } else {
        res.status(400).json({ success: false, error: 'No speech detected in audio' });
      }
    } else {
      res.status(400).json({ success: false, error: 'No speech detected in audio' });
    }

  } catch (error) {
    console.error('Error transcribing audio with Google Speech-to-Text:', error);
    
    // Clean up temporary file if it exists
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }
    
    let errorMessage = 'Failed to transcribe audio';
    
    if (error.code === 'UNAUTHENTICATED') {
      errorMessage = 'Google Cloud API key not configured or invalid';
    } else if (error.code === 'INVALID_ARGUMENT') {
      errorMessage = 'Invalid audio format or configuration';
    } else if (error.code === 'RESOURCE_EXHAUSTED') {
      errorMessage = 'Google Speech-to-Text quota exceeded';
    } else if (error.message?.includes('not found')) {
      errorMessage = 'Google Speech-to-Text service not available';
    }
    
    res.status(500).json({ success: false, error: errorMessage });
  }
});

// Voice Cloning Endpoints

// Upload voice sample for cloning
router.post('/voice-clone/upload', auth, upload.single('audio'), async (req, res) => {
  try {
    const { voiceName } = req.body;
    const userId = req.user._id;
    
    if (!req.file) {
      return res.status(400).json({ success: false, error: 'No voice file provided' });
    }
    
    if (!voiceName) {
      return res.status(400).json({ 
        success: false, 
        error: 'Voice name is required' 
      });
    }
    
    // Check user credits (voice cloning costs 2 credits)
    const user = await User.findById(userId);
    if (!user || user.credits < 2) {
      if (fs.existsSync(req.file.path)) {
        fs.unlinkSync(req.file.path);
      }
      return res.status(400).json({ 
        success: false, 
        error: 'Insufficient credits. Voice cloning costs 2 credits.' 
      });
    }
    
    console.log('Uploading voice sample to ElevenLabs for cloning:', req.file.path);
    console.log('Voice file details:', {
      size: req.file.size,
      mimetype: req.file.mimetype,
      originalname: req.file.originalname
    });
    console.log('Using ElevenLabs API key:', process.env.ELEVEN_API_KEY ? 'Present' : 'Missing');
    
    try {
      // Create FormData for ElevenLabs API
      const formData = new FormData();
      formData.append('name', voiceName.trim());
      formData.append('files', fs.createReadStream(req.file.path), {
        filename: req.file.originalname || 'voice_sample.mp3',
        contentType: req.file.mimetype || 'audio/mpeg'
      });
      formData.append('description', `Custom voice for ${user.username}`);
      
      // Call ElevenLabs Voice Cloning API
      const cloneResponse = await axios.post(
        'https://api.elevenlabs.io/v1/voices/add',
        formData,
        {
          headers: {
            'Accept': 'application/json',
            'xi-api-key': process.env.ELEVEN_LABS_API_KEY,
            ...formData.getHeaders()
          },
          timeout: 60000 // 60 second timeout for voice cloning
        }
      );
      
      const voiceId = cloneResponse.data.voice_id;
      
      if (!voiceId) {
        throw new Error('No voice ID returned from ElevenLabs');
      }
      
      // Save voice to user's custom voices
      await user.addCustomVoice(voiceId, voiceName);
      console.log(`Voice ${voiceId} added to user ${user.username}'s custom voices`);
      
      // Deduct credits
      await user.spendCredits(2, 'generation', `Voice cloning: "${voiceName}"`, voiceId);
      
      // Clean up temporary file
      if (fs.existsSync(req.file.path)) {
        fs.unlinkSync(req.file.path);
      }
      
      res.json({
        success: true,
        voiceId: voiceId,
        voiceName: voiceName,
        message: 'Voice cloned successfully'
      });
      
    } catch (elevenLabsError) {
      console.error('ElevenLabs voice cloning error:', elevenLabsError);
      
      // Clean up temporary file
      if (fs.existsSync(req.file.path)) {
        fs.unlinkSync(req.file.path);
      }
      
      let errorMessage = 'Failed to clone voice. Please try again.';
      
      if (elevenLabsError.response?.status === 422) {
        errorMessage = 'Voice sample quality is insufficient. Please record a clearer sample.';
      } else if (elevenLabsError.response?.status === 429) {
        errorMessage = 'ElevenLabs API rate limit exceeded. Please try again later.';
      } else if (elevenLabsError.code === 'ECONNABORTED') {
        errorMessage = 'Voice cloning timed out. Please try with a shorter audio sample.';
      }
      
      res.status(500).json({ 
        success: false, 
        error: errorMessage
      });
    }
    
  } catch (error) {
    console.error('Error in voice cloning upload:', error);
    
    // Clean up temporary file
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }
    
    res.status(500).json({ success: false, error: 'Failed to process voice cloning request' });
  }
});

// Get user's custom voices
router.get('/voice-clone/list', auth, async (req, res) => {
  try {
    const userId = req.user._id;
    
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    const customVoices = user.getCustomVoices();
    console.log(`Found ${customVoices.length} custom voices for user ${user.username}:`, customVoices);
    
    res.json({
      success: true,
      voices: customVoices
    });
    
  } catch (error) {
    console.error('Error fetching custom voices:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch custom voices' });
  }
});

// Delete custom voice
router.delete('/voice-clone/:voiceId', auth, async (req, res) => {
  try {
    const { voiceId } = req.params;
    const userId = req.user._id;
    
    
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    // Check if user owns this voice
    const voiceExists = user.customVoices.find(voice => voice.voiceId === voiceId);
    if (!voiceExists) {
      return res.status(404).json({ success: false, error: 'Voice not found' });
    }
    
    try {
      // Delete voice from ElevenLabs
      await axios.delete(`https://api.elevenlabs.io/v1/voices/${voiceId}`, {
        headers: {
          'xi-api-key': process.env.ELEVEN_API_KEY
        }
      });
    } catch (elevenLabsError) {
      console.warn('Failed to delete voice from ElevenLabs (continuing anyway):', elevenLabsError.message);
      // Continue with local deletion even if ElevenLabs deletion fails
    }
    
    // Remove voice from user's custom voices
    await user.removeCustomVoice(voiceId);
    
    res.json({
      success: true,
      message: 'Custom voice deleted successfully'
    });
    
  } catch (error) {
    console.error('Error deleting custom voice:', error);
    res.status(500).json({ success: false, error: 'Failed to delete custom voice' });
  }
});

module.exports = router;